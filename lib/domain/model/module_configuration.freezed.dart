// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'module_configuration.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ModuleConfiguration {
  CustomConfig? get custom => throw _privateConstructorUsedError;
  DataConfig? get data => throw _privateConstructorUsedError;
  Map<String, String?>? get defaultDisplayFieldNames =>
      throw _privateConstructorUsedError;
  Map<String, String?>? get displayFieldNames =>
      throw _privateConstructorUsedError;
  ModuleConfig? get module => throw _privateConstructorUsedError;
  ObjectConfig? get observation => throw _privateConstructorUsedError;
  ObjectConfig? get site => throw _privateConstructorUsedError;
  ObjectConfig? get sitesGroup => throw _privateConstructorUsedError;
  dynamic get synthese => throw _privateConstructorUsedError;
  TreeConfig? get tree => throw _privateConstructorUsedError;
  ObjectConfig? get visit => throw _privateConstructorUsedError;

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ModuleConfigurationCopyWith<ModuleConfiguration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModuleConfigurationCopyWith<$Res> {
  factory $ModuleConfigurationCopyWith(
          ModuleConfiguration value, $Res Function(ModuleConfiguration) then) =
      _$ModuleConfigurationCopyWithImpl<$Res, ModuleConfiguration>;
  @useResult
  $Res call(
      {CustomConfig? custom,
      DataConfig? data,
      Map<String, String?>? defaultDisplayFieldNames,
      Map<String, String?>? displayFieldNames,
      ModuleConfig? module,
      ObjectConfig? observation,
      ObjectConfig? site,
      ObjectConfig? sitesGroup,
      dynamic synthese,
      TreeConfig? tree,
      ObjectConfig? visit});

  $CustomConfigCopyWith<$Res>? get custom;
  $DataConfigCopyWith<$Res>? get data;
  $ModuleConfigCopyWith<$Res>? get module;
  $ObjectConfigCopyWith<$Res>? get observation;
  $ObjectConfigCopyWith<$Res>? get site;
  $ObjectConfigCopyWith<$Res>? get sitesGroup;
  $TreeConfigCopyWith<$Res>? get tree;
  $ObjectConfigCopyWith<$Res>? get visit;
}

/// @nodoc
class _$ModuleConfigurationCopyWithImpl<$Res, $Val extends ModuleConfiguration>
    implements $ModuleConfigurationCopyWith<$Res> {
  _$ModuleConfigurationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? custom = freezed,
    Object? data = freezed,
    Object? defaultDisplayFieldNames = freezed,
    Object? displayFieldNames = freezed,
    Object? module = freezed,
    Object? observation = freezed,
    Object? site = freezed,
    Object? sitesGroup = freezed,
    Object? synthese = freezed,
    Object? tree = freezed,
    Object? visit = freezed,
  }) {
    return _then(_value.copyWith(
      custom: freezed == custom
          ? _value.custom
          : custom // ignore: cast_nullable_to_non_nullable
              as CustomConfig?,
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as DataConfig?,
      defaultDisplayFieldNames: freezed == defaultDisplayFieldNames
          ? _value.defaultDisplayFieldNames
          : defaultDisplayFieldNames // ignore: cast_nullable_to_non_nullable
              as Map<String, String?>?,
      displayFieldNames: freezed == displayFieldNames
          ? _value.displayFieldNames
          : displayFieldNames // ignore: cast_nullable_to_non_nullable
              as Map<String, String?>?,
      module: freezed == module
          ? _value.module
          : module // ignore: cast_nullable_to_non_nullable
              as ModuleConfig?,
      observation: freezed == observation
          ? _value.observation
          : observation // ignore: cast_nullable_to_non_nullable
              as ObjectConfig?,
      site: freezed == site
          ? _value.site
          : site // ignore: cast_nullable_to_non_nullable
              as ObjectConfig?,
      sitesGroup: freezed == sitesGroup
          ? _value.sitesGroup
          : sitesGroup // ignore: cast_nullable_to_non_nullable
              as ObjectConfig?,
      synthese: freezed == synthese
          ? _value.synthese
          : synthese // ignore: cast_nullable_to_non_nullable
              as dynamic,
      tree: freezed == tree
          ? _value.tree
          : tree // ignore: cast_nullable_to_non_nullable
              as TreeConfig?,
      visit: freezed == visit
          ? _value.visit
          : visit // ignore: cast_nullable_to_non_nullable
              as ObjectConfig?,
    ) as $Val);
  }

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CustomConfigCopyWith<$Res>? get custom {
    if (_value.custom == null) {
      return null;
    }

    return $CustomConfigCopyWith<$Res>(_value.custom!, (value) {
      return _then(_value.copyWith(custom: value) as $Val);
    });
  }

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DataConfigCopyWith<$Res>? get data {
    if (_value.data == null) {
      return null;
    }

    return $DataConfigCopyWith<$Res>(_value.data!, (value) {
      return _then(_value.copyWith(data: value) as $Val);
    });
  }

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ModuleConfigCopyWith<$Res>? get module {
    if (_value.module == null) {
      return null;
    }

    return $ModuleConfigCopyWith<$Res>(_value.module!, (value) {
      return _then(_value.copyWith(module: value) as $Val);
    });
  }

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ObjectConfigCopyWith<$Res>? get observation {
    if (_value.observation == null) {
      return null;
    }

    return $ObjectConfigCopyWith<$Res>(_value.observation!, (value) {
      return _then(_value.copyWith(observation: value) as $Val);
    });
  }

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ObjectConfigCopyWith<$Res>? get site {
    if (_value.site == null) {
      return null;
    }

    return $ObjectConfigCopyWith<$Res>(_value.site!, (value) {
      return _then(_value.copyWith(site: value) as $Val);
    });
  }

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ObjectConfigCopyWith<$Res>? get sitesGroup {
    if (_value.sitesGroup == null) {
      return null;
    }

    return $ObjectConfigCopyWith<$Res>(_value.sitesGroup!, (value) {
      return _then(_value.copyWith(sitesGroup: value) as $Val);
    });
  }

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TreeConfigCopyWith<$Res>? get tree {
    if (_value.tree == null) {
      return null;
    }

    return $TreeConfigCopyWith<$Res>(_value.tree!, (value) {
      return _then(_value.copyWith(tree: value) as $Val);
    });
  }

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ObjectConfigCopyWith<$Res>? get visit {
    if (_value.visit == null) {
      return null;
    }

    return $ObjectConfigCopyWith<$Res>(_value.visit!, (value) {
      return _then(_value.copyWith(visit: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ModuleConfigurationImplCopyWith<$Res>
    implements $ModuleConfigurationCopyWith<$Res> {
  factory _$$ModuleConfigurationImplCopyWith(_$ModuleConfigurationImpl value,
          $Res Function(_$ModuleConfigurationImpl) then) =
      __$$ModuleConfigurationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {CustomConfig? custom,
      DataConfig? data,
      Map<String, String?>? defaultDisplayFieldNames,
      Map<String, String?>? displayFieldNames,
      ModuleConfig? module,
      ObjectConfig? observation,
      ObjectConfig? site,
      ObjectConfig? sitesGroup,
      dynamic synthese,
      TreeConfig? tree,
      ObjectConfig? visit});

  @override
  $CustomConfigCopyWith<$Res>? get custom;
  @override
  $DataConfigCopyWith<$Res>? get data;
  @override
  $ModuleConfigCopyWith<$Res>? get module;
  @override
  $ObjectConfigCopyWith<$Res>? get observation;
  @override
  $ObjectConfigCopyWith<$Res>? get site;
  @override
  $ObjectConfigCopyWith<$Res>? get sitesGroup;
  @override
  $TreeConfigCopyWith<$Res>? get tree;
  @override
  $ObjectConfigCopyWith<$Res>? get visit;
}

/// @nodoc
class __$$ModuleConfigurationImplCopyWithImpl<$Res>
    extends _$ModuleConfigurationCopyWithImpl<$Res, _$ModuleConfigurationImpl>
    implements _$$ModuleConfigurationImplCopyWith<$Res> {
  __$$ModuleConfigurationImplCopyWithImpl(_$ModuleConfigurationImpl _value,
      $Res Function(_$ModuleConfigurationImpl) _then)
      : super(_value, _then);

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? custom = freezed,
    Object? data = freezed,
    Object? defaultDisplayFieldNames = freezed,
    Object? displayFieldNames = freezed,
    Object? module = freezed,
    Object? observation = freezed,
    Object? site = freezed,
    Object? sitesGroup = freezed,
    Object? synthese = freezed,
    Object? tree = freezed,
    Object? visit = freezed,
  }) {
    return _then(_$ModuleConfigurationImpl(
      custom: freezed == custom
          ? _value.custom
          : custom // ignore: cast_nullable_to_non_nullable
              as CustomConfig?,
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as DataConfig?,
      defaultDisplayFieldNames: freezed == defaultDisplayFieldNames
          ? _value._defaultDisplayFieldNames
          : defaultDisplayFieldNames // ignore: cast_nullable_to_non_nullable
              as Map<String, String?>?,
      displayFieldNames: freezed == displayFieldNames
          ? _value._displayFieldNames
          : displayFieldNames // ignore: cast_nullable_to_non_nullable
              as Map<String, String?>?,
      module: freezed == module
          ? _value.module
          : module // ignore: cast_nullable_to_non_nullable
              as ModuleConfig?,
      observation: freezed == observation
          ? _value.observation
          : observation // ignore: cast_nullable_to_non_nullable
              as ObjectConfig?,
      site: freezed == site
          ? _value.site
          : site // ignore: cast_nullable_to_non_nullable
              as ObjectConfig?,
      sitesGroup: freezed == sitesGroup
          ? _value.sitesGroup
          : sitesGroup // ignore: cast_nullable_to_non_nullable
              as ObjectConfig?,
      synthese: freezed == synthese
          ? _value.synthese
          : synthese // ignore: cast_nullable_to_non_nullable
              as dynamic,
      tree: freezed == tree
          ? _value.tree
          : tree // ignore: cast_nullable_to_non_nullable
              as TreeConfig?,
      visit: freezed == visit
          ? _value.visit
          : visit // ignore: cast_nullable_to_non_nullable
              as ObjectConfig?,
    ));
  }
}

/// @nodoc

class _$ModuleConfigurationImpl implements _ModuleConfiguration {
  const _$ModuleConfigurationImpl(
      {this.custom,
      this.data,
      final Map<String, String?>? defaultDisplayFieldNames,
      final Map<String, String?>? displayFieldNames,
      this.module,
      this.observation,
      this.site,
      this.sitesGroup,
      this.synthese,
      this.tree,
      this.visit})
      : _defaultDisplayFieldNames = defaultDisplayFieldNames,
        _displayFieldNames = displayFieldNames;

  @override
  final CustomConfig? custom;
  @override
  final DataConfig? data;
  final Map<String, String?>? _defaultDisplayFieldNames;
  @override
  Map<String, String?>? get defaultDisplayFieldNames {
    final value = _defaultDisplayFieldNames;
    if (value == null) return null;
    if (_defaultDisplayFieldNames is EqualUnmodifiableMapView)
      return _defaultDisplayFieldNames;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, String?>? _displayFieldNames;
  @override
  Map<String, String?>? get displayFieldNames {
    final value = _displayFieldNames;
    if (value == null) return null;
    if (_displayFieldNames is EqualUnmodifiableMapView)
      return _displayFieldNames;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final ModuleConfig? module;
  @override
  final ObjectConfig? observation;
  @override
  final ObjectConfig? site;
  @override
  final ObjectConfig? sitesGroup;
  @override
  final dynamic synthese;
  @override
  final TreeConfig? tree;
  @override
  final ObjectConfig? visit;

  @override
  String toString() {
    return 'ModuleConfiguration(custom: $custom, data: $data, defaultDisplayFieldNames: $defaultDisplayFieldNames, displayFieldNames: $displayFieldNames, module: $module, observation: $observation, site: $site, sitesGroup: $sitesGroup, synthese: $synthese, tree: $tree, visit: $visit)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModuleConfigurationImpl &&
            (identical(other.custom, custom) || other.custom == custom) &&
            (identical(other.data, data) || other.data == data) &&
            const DeepCollectionEquality().equals(
                other._defaultDisplayFieldNames, _defaultDisplayFieldNames) &&
            const DeepCollectionEquality()
                .equals(other._displayFieldNames, _displayFieldNames) &&
            (identical(other.module, module) || other.module == module) &&
            (identical(other.observation, observation) ||
                other.observation == observation) &&
            (identical(other.site, site) || other.site == site) &&
            (identical(other.sitesGroup, sitesGroup) ||
                other.sitesGroup == sitesGroup) &&
            const DeepCollectionEquality().equals(other.synthese, synthese) &&
            (identical(other.tree, tree) || other.tree == tree) &&
            (identical(other.visit, visit) || other.visit == visit));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      custom,
      data,
      const DeepCollectionEquality().hash(_defaultDisplayFieldNames),
      const DeepCollectionEquality().hash(_displayFieldNames),
      module,
      observation,
      site,
      sitesGroup,
      const DeepCollectionEquality().hash(synthese),
      tree,
      visit);

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ModuleConfigurationImplCopyWith<_$ModuleConfigurationImpl> get copyWith =>
      __$$ModuleConfigurationImplCopyWithImpl<_$ModuleConfigurationImpl>(
          this, _$identity);
}

abstract class _ModuleConfiguration implements ModuleConfiguration {
  const factory _ModuleConfiguration(
      {final CustomConfig? custom,
      final DataConfig? data,
      final Map<String, String?>? defaultDisplayFieldNames,
      final Map<String, String?>? displayFieldNames,
      final ModuleConfig? module,
      final ObjectConfig? observation,
      final ObjectConfig? site,
      final ObjectConfig? sitesGroup,
      final dynamic synthese,
      final TreeConfig? tree,
      final ObjectConfig? visit}) = _$ModuleConfigurationImpl;

  @override
  CustomConfig? get custom;
  @override
  DataConfig? get data;
  @override
  Map<String, String?>? get defaultDisplayFieldNames;
  @override
  Map<String, String?>? get displayFieldNames;
  @override
  ModuleConfig? get module;
  @override
  ObjectConfig? get observation;
  @override
  ObjectConfig? get site;
  @override
  ObjectConfig? get sitesGroup;
  @override
  dynamic get synthese;
  @override
  TreeConfig? get tree;
  @override
  ObjectConfig? get visit;

  /// Create a copy of ModuleConfiguration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ModuleConfigurationImplCopyWith<_$ModuleConfigurationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CustomConfig {
  @JsonKey(name: '__MODULE.B_DRAW_SITES_GROUP')
  bool? get drawSitesGroup => throw _privateConstructorUsedError;
  @JsonKey(name: '__MODULE.B_SYNTHESE')
  bool? get synthese => throw _privateConstructorUsedError;
  @JsonKey(name: '__MODULE.IDS_TYPE_SITE')
  List<TypeSite>? get typeSites => throw _privateConstructorUsedError;
  @JsonKey(name: '__MODULE.ID_LIST_OBSERVER')
  int? get idListObserver => throw _privateConstructorUsedError;
  @JsonKey(name: '__MODULE.ID_LIST_TAXONOMY')
  int? get idListTaxonomy => throw _privateConstructorUsedError;
  @JsonKey(name: '__MODULE.ID_MODULE')
  int? get idModule => throw _privateConstructorUsedError;
  @JsonKey(name: '__MODULE.MODULE_CODE')
  String? get moduleCode => throw _privateConstructorUsedError;
  @JsonKey(name: '__MODULE.TAXONOMY_DISPLAY_FIELD_NAME')
  String? get taxonomyDisplayFieldName => throw _privateConstructorUsedError;
  @JsonKey(name: '__MODULE.TYPES_SITE')
  List<TypeSite>? get typesSite => throw _privateConstructorUsedError;
  @JsonKey(name: '__MONITORINGS_PATH')
  String? get monitoringsPath => throw _privateConstructorUsedError;

  /// Create a copy of CustomConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CustomConfigCopyWith<CustomConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomConfigCopyWith<$Res> {
  factory $CustomConfigCopyWith(
          CustomConfig value, $Res Function(CustomConfig) then) =
      _$CustomConfigCopyWithImpl<$Res, CustomConfig>;
  @useResult
  $Res call(
      {@JsonKey(name: '__MODULE.B_DRAW_SITES_GROUP') bool? drawSitesGroup,
      @JsonKey(name: '__MODULE.B_SYNTHESE') bool? synthese,
      @JsonKey(name: '__MODULE.IDS_TYPE_SITE') List<TypeSite>? typeSites,
      @JsonKey(name: '__MODULE.ID_LIST_OBSERVER') int? idListObserver,
      @JsonKey(name: '__MODULE.ID_LIST_TAXONOMY') int? idListTaxonomy,
      @JsonKey(name: '__MODULE.ID_MODULE') int? idModule,
      @JsonKey(name: '__MODULE.MODULE_CODE') String? moduleCode,
      @JsonKey(name: '__MODULE.TAXONOMY_DISPLAY_FIELD_NAME')
      String? taxonomyDisplayFieldName,
      @JsonKey(name: '__MODULE.TYPES_SITE') List<TypeSite>? typesSite,
      @JsonKey(name: '__MONITORINGS_PATH') String? monitoringsPath});
}

/// @nodoc
class _$CustomConfigCopyWithImpl<$Res, $Val extends CustomConfig>
    implements $CustomConfigCopyWith<$Res> {
  _$CustomConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CustomConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? drawSitesGroup = freezed,
    Object? synthese = freezed,
    Object? typeSites = freezed,
    Object? idListObserver = freezed,
    Object? idListTaxonomy = freezed,
    Object? idModule = freezed,
    Object? moduleCode = freezed,
    Object? taxonomyDisplayFieldName = freezed,
    Object? typesSite = freezed,
    Object? monitoringsPath = freezed,
  }) {
    return _then(_value.copyWith(
      drawSitesGroup: freezed == drawSitesGroup
          ? _value.drawSitesGroup
          : drawSitesGroup // ignore: cast_nullable_to_non_nullable
              as bool?,
      synthese: freezed == synthese
          ? _value.synthese
          : synthese // ignore: cast_nullable_to_non_nullable
              as bool?,
      typeSites: freezed == typeSites
          ? _value.typeSites
          : typeSites // ignore: cast_nullable_to_non_nullable
              as List<TypeSite>?,
      idListObserver: freezed == idListObserver
          ? _value.idListObserver
          : idListObserver // ignore: cast_nullable_to_non_nullable
              as int?,
      idListTaxonomy: freezed == idListTaxonomy
          ? _value.idListTaxonomy
          : idListTaxonomy // ignore: cast_nullable_to_non_nullable
              as int?,
      idModule: freezed == idModule
          ? _value.idModule
          : idModule // ignore: cast_nullable_to_non_nullable
              as int?,
      moduleCode: freezed == moduleCode
          ? _value.moduleCode
          : moduleCode // ignore: cast_nullable_to_non_nullable
              as String?,
      taxonomyDisplayFieldName: freezed == taxonomyDisplayFieldName
          ? _value.taxonomyDisplayFieldName
          : taxonomyDisplayFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      typesSite: freezed == typesSite
          ? _value.typesSite
          : typesSite // ignore: cast_nullable_to_non_nullable
              as List<TypeSite>?,
      monitoringsPath: freezed == monitoringsPath
          ? _value.monitoringsPath
          : monitoringsPath // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CustomConfigImplCopyWith<$Res>
    implements $CustomConfigCopyWith<$Res> {
  factory _$$CustomConfigImplCopyWith(
          _$CustomConfigImpl value, $Res Function(_$CustomConfigImpl) then) =
      __$$CustomConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: '__MODULE.B_DRAW_SITES_GROUP') bool? drawSitesGroup,
      @JsonKey(name: '__MODULE.B_SYNTHESE') bool? synthese,
      @JsonKey(name: '__MODULE.IDS_TYPE_SITE') List<TypeSite>? typeSites,
      @JsonKey(name: '__MODULE.ID_LIST_OBSERVER') int? idListObserver,
      @JsonKey(name: '__MODULE.ID_LIST_TAXONOMY') int? idListTaxonomy,
      @JsonKey(name: '__MODULE.ID_MODULE') int? idModule,
      @JsonKey(name: '__MODULE.MODULE_CODE') String? moduleCode,
      @JsonKey(name: '__MODULE.TAXONOMY_DISPLAY_FIELD_NAME')
      String? taxonomyDisplayFieldName,
      @JsonKey(name: '__MODULE.TYPES_SITE') List<TypeSite>? typesSite,
      @JsonKey(name: '__MONITORINGS_PATH') String? monitoringsPath});
}

/// @nodoc
class __$$CustomConfigImplCopyWithImpl<$Res>
    extends _$CustomConfigCopyWithImpl<$Res, _$CustomConfigImpl>
    implements _$$CustomConfigImplCopyWith<$Res> {
  __$$CustomConfigImplCopyWithImpl(
      _$CustomConfigImpl _value, $Res Function(_$CustomConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of CustomConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? drawSitesGroup = freezed,
    Object? synthese = freezed,
    Object? typeSites = freezed,
    Object? idListObserver = freezed,
    Object? idListTaxonomy = freezed,
    Object? idModule = freezed,
    Object? moduleCode = freezed,
    Object? taxonomyDisplayFieldName = freezed,
    Object? typesSite = freezed,
    Object? monitoringsPath = freezed,
  }) {
    return _then(_$CustomConfigImpl(
      drawSitesGroup: freezed == drawSitesGroup
          ? _value.drawSitesGroup
          : drawSitesGroup // ignore: cast_nullable_to_non_nullable
              as bool?,
      synthese: freezed == synthese
          ? _value.synthese
          : synthese // ignore: cast_nullable_to_non_nullable
              as bool?,
      typeSites: freezed == typeSites
          ? _value._typeSites
          : typeSites // ignore: cast_nullable_to_non_nullable
              as List<TypeSite>?,
      idListObserver: freezed == idListObserver
          ? _value.idListObserver
          : idListObserver // ignore: cast_nullable_to_non_nullable
              as int?,
      idListTaxonomy: freezed == idListTaxonomy
          ? _value.idListTaxonomy
          : idListTaxonomy // ignore: cast_nullable_to_non_nullable
              as int?,
      idModule: freezed == idModule
          ? _value.idModule
          : idModule // ignore: cast_nullable_to_non_nullable
              as int?,
      moduleCode: freezed == moduleCode
          ? _value.moduleCode
          : moduleCode // ignore: cast_nullable_to_non_nullable
              as String?,
      taxonomyDisplayFieldName: freezed == taxonomyDisplayFieldName
          ? _value.taxonomyDisplayFieldName
          : taxonomyDisplayFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      typesSite: freezed == typesSite
          ? _value._typesSite
          : typesSite // ignore: cast_nullable_to_non_nullable
              as List<TypeSite>?,
      monitoringsPath: freezed == monitoringsPath
          ? _value.monitoringsPath
          : monitoringsPath // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$CustomConfigImpl implements _CustomConfig {
  const _$CustomConfigImpl(
      {@JsonKey(name: '__MODULE.B_DRAW_SITES_GROUP') this.drawSitesGroup,
      @JsonKey(name: '__MODULE.B_SYNTHESE') this.synthese,
      @JsonKey(name: '__MODULE.IDS_TYPE_SITE') final List<TypeSite>? typeSites,
      @JsonKey(name: '__MODULE.ID_LIST_OBSERVER') this.idListObserver,
      @JsonKey(name: '__MODULE.ID_LIST_TAXONOMY') this.idListTaxonomy,
      @JsonKey(name: '__MODULE.ID_MODULE') this.idModule,
      @JsonKey(name: '__MODULE.MODULE_CODE') this.moduleCode,
      @JsonKey(name: '__MODULE.TAXONOMY_DISPLAY_FIELD_NAME')
      this.taxonomyDisplayFieldName,
      @JsonKey(name: '__MODULE.TYPES_SITE') final List<TypeSite>? typesSite,
      @JsonKey(name: '__MONITORINGS_PATH') this.monitoringsPath})
      : _typeSites = typeSites,
        _typesSite = typesSite;

  @override
  @JsonKey(name: '__MODULE.B_DRAW_SITES_GROUP')
  final bool? drawSitesGroup;
  @override
  @JsonKey(name: '__MODULE.B_SYNTHESE')
  final bool? synthese;
  final List<TypeSite>? _typeSites;
  @override
  @JsonKey(name: '__MODULE.IDS_TYPE_SITE')
  List<TypeSite>? get typeSites {
    final value = _typeSites;
    if (value == null) return null;
    if (_typeSites is EqualUnmodifiableListView) return _typeSites;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: '__MODULE.ID_LIST_OBSERVER')
  final int? idListObserver;
  @override
  @JsonKey(name: '__MODULE.ID_LIST_TAXONOMY')
  final int? idListTaxonomy;
  @override
  @JsonKey(name: '__MODULE.ID_MODULE')
  final int? idModule;
  @override
  @JsonKey(name: '__MODULE.MODULE_CODE')
  final String? moduleCode;
  @override
  @JsonKey(name: '__MODULE.TAXONOMY_DISPLAY_FIELD_NAME')
  final String? taxonomyDisplayFieldName;
  final List<TypeSite>? _typesSite;
  @override
  @JsonKey(name: '__MODULE.TYPES_SITE')
  List<TypeSite>? get typesSite {
    final value = _typesSite;
    if (value == null) return null;
    if (_typesSite is EqualUnmodifiableListView) return _typesSite;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: '__MONITORINGS_PATH')
  final String? monitoringsPath;

  @override
  String toString() {
    return 'CustomConfig(drawSitesGroup: $drawSitesGroup, synthese: $synthese, typeSites: $typeSites, idListObserver: $idListObserver, idListTaxonomy: $idListTaxonomy, idModule: $idModule, moduleCode: $moduleCode, taxonomyDisplayFieldName: $taxonomyDisplayFieldName, typesSite: $typesSite, monitoringsPath: $monitoringsPath)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomConfigImpl &&
            (identical(other.drawSitesGroup, drawSitesGroup) ||
                other.drawSitesGroup == drawSitesGroup) &&
            (identical(other.synthese, synthese) ||
                other.synthese == synthese) &&
            const DeepCollectionEquality()
                .equals(other._typeSites, _typeSites) &&
            (identical(other.idListObserver, idListObserver) ||
                other.idListObserver == idListObserver) &&
            (identical(other.idListTaxonomy, idListTaxonomy) ||
                other.idListTaxonomy == idListTaxonomy) &&
            (identical(other.idModule, idModule) ||
                other.idModule == idModule) &&
            (identical(other.moduleCode, moduleCode) ||
                other.moduleCode == moduleCode) &&
            (identical(
                    other.taxonomyDisplayFieldName, taxonomyDisplayFieldName) ||
                other.taxonomyDisplayFieldName == taxonomyDisplayFieldName) &&
            const DeepCollectionEquality()
                .equals(other._typesSite, _typesSite) &&
            (identical(other.monitoringsPath, monitoringsPath) ||
                other.monitoringsPath == monitoringsPath));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      drawSitesGroup,
      synthese,
      const DeepCollectionEquality().hash(_typeSites),
      idListObserver,
      idListTaxonomy,
      idModule,
      moduleCode,
      taxonomyDisplayFieldName,
      const DeepCollectionEquality().hash(_typesSite),
      monitoringsPath);

  /// Create a copy of CustomConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomConfigImplCopyWith<_$CustomConfigImpl> get copyWith =>
      __$$CustomConfigImplCopyWithImpl<_$CustomConfigImpl>(this, _$identity);
}

abstract class _CustomConfig implements CustomConfig {
  const factory _CustomConfig(
      {@JsonKey(name: '__MODULE.B_DRAW_SITES_GROUP') final bool? drawSitesGroup,
      @JsonKey(name: '__MODULE.B_SYNTHESE') final bool? synthese,
      @JsonKey(name: '__MODULE.IDS_TYPE_SITE') final List<TypeSite>? typeSites,
      @JsonKey(name: '__MODULE.ID_LIST_OBSERVER') final int? idListObserver,
      @JsonKey(name: '__MODULE.ID_LIST_TAXONOMY') final int? idListTaxonomy,
      @JsonKey(name: '__MODULE.ID_MODULE') final int? idModule,
      @JsonKey(name: '__MODULE.MODULE_CODE') final String? moduleCode,
      @JsonKey(name: '__MODULE.TAXONOMY_DISPLAY_FIELD_NAME')
      final String? taxonomyDisplayFieldName,
      @JsonKey(name: '__MODULE.TYPES_SITE') final List<TypeSite>? typesSite,
      @JsonKey(name: '__MONITORINGS_PATH')
      final String? monitoringsPath}) = _$CustomConfigImpl;

  @override
  @JsonKey(name: '__MODULE.B_DRAW_SITES_GROUP')
  bool? get drawSitesGroup;
  @override
  @JsonKey(name: '__MODULE.B_SYNTHESE')
  bool? get synthese;
  @override
  @JsonKey(name: '__MODULE.IDS_TYPE_SITE')
  List<TypeSite>? get typeSites;
  @override
  @JsonKey(name: '__MODULE.ID_LIST_OBSERVER')
  int? get idListObserver;
  @override
  @JsonKey(name: '__MODULE.ID_LIST_TAXONOMY')
  int? get idListTaxonomy;
  @override
  @JsonKey(name: '__MODULE.ID_MODULE')
  int? get idModule;
  @override
  @JsonKey(name: '__MODULE.MODULE_CODE')
  String? get moduleCode;
  @override
  @JsonKey(name: '__MODULE.TAXONOMY_DISPLAY_FIELD_NAME')
  String? get taxonomyDisplayFieldName;
  @override
  @JsonKey(name: '__MODULE.TYPES_SITE')
  List<TypeSite>? get typesSite;
  @override
  @JsonKey(name: '__MONITORINGS_PATH')
  String? get monitoringsPath;

  /// Create a copy of CustomConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CustomConfigImplCopyWith<_$CustomConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TypeSite {
  int? get idNomenclatureTypeSite => throw _privateConstructorUsedError;
  dynamic get config => throw _privateConstructorUsedError;

  /// Create a copy of TypeSite
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TypeSiteCopyWith<TypeSite> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypeSiteCopyWith<$Res> {
  factory $TypeSiteCopyWith(TypeSite value, $Res Function(TypeSite) then) =
      _$TypeSiteCopyWithImpl<$Res, TypeSite>;
  @useResult
  $Res call({int? idNomenclatureTypeSite, dynamic config});
}

/// @nodoc
class _$TypeSiteCopyWithImpl<$Res, $Val extends TypeSite>
    implements $TypeSiteCopyWith<$Res> {
  _$TypeSiteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TypeSite
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idNomenclatureTypeSite = freezed,
    Object? config = freezed,
  }) {
    return _then(_value.copyWith(
      idNomenclatureTypeSite: freezed == idNomenclatureTypeSite
          ? _value.idNomenclatureTypeSite
          : idNomenclatureTypeSite // ignore: cast_nullable_to_non_nullable
              as int?,
      config: freezed == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TypeSiteImplCopyWith<$Res>
    implements $TypeSiteCopyWith<$Res> {
  factory _$$TypeSiteImplCopyWith(
          _$TypeSiteImpl value, $Res Function(_$TypeSiteImpl) then) =
      __$$TypeSiteImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? idNomenclatureTypeSite, dynamic config});
}

/// @nodoc
class __$$TypeSiteImplCopyWithImpl<$Res>
    extends _$TypeSiteCopyWithImpl<$Res, _$TypeSiteImpl>
    implements _$$TypeSiteImplCopyWith<$Res> {
  __$$TypeSiteImplCopyWithImpl(
      _$TypeSiteImpl _value, $Res Function(_$TypeSiteImpl) _then)
      : super(_value, _then);

  /// Create a copy of TypeSite
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idNomenclatureTypeSite = freezed,
    Object? config = freezed,
  }) {
    return _then(_$TypeSiteImpl(
      idNomenclatureTypeSite: freezed == idNomenclatureTypeSite
          ? _value.idNomenclatureTypeSite
          : idNomenclatureTypeSite // ignore: cast_nullable_to_non_nullable
              as int?,
      config: freezed == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$TypeSiteImpl implements _TypeSite {
  const _$TypeSiteImpl({this.idNomenclatureTypeSite, this.config});

  @override
  final int? idNomenclatureTypeSite;
  @override
  final dynamic config;

  @override
  String toString() {
    return 'TypeSite(idNomenclatureTypeSite: $idNomenclatureTypeSite, config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TypeSiteImpl &&
            (identical(other.idNomenclatureTypeSite, idNomenclatureTypeSite) ||
                other.idNomenclatureTypeSite == idNomenclatureTypeSite) &&
            const DeepCollectionEquality().equals(other.config, config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, idNomenclatureTypeSite,
      const DeepCollectionEquality().hash(config));

  /// Create a copy of TypeSite
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TypeSiteImplCopyWith<_$TypeSiteImpl> get copyWith =>
      __$$TypeSiteImplCopyWithImpl<_$TypeSiteImpl>(this, _$identity);
}

abstract class _TypeSite implements TypeSite {
  const factory _TypeSite(
      {final int? idNomenclatureTypeSite,
      final dynamic config}) = _$TypeSiteImpl;

  @override
  int? get idNomenclatureTypeSite;
  @override
  dynamic get config;

  /// Create a copy of TypeSite
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TypeSiteImplCopyWith<_$TypeSiteImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DataConfig {
  List<String>? get nomenclature => throw _privateConstructorUsedError;
  int? get user => throw _privateConstructorUsedError;

  /// Create a copy of DataConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DataConfigCopyWith<DataConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataConfigCopyWith<$Res> {
  factory $DataConfigCopyWith(
          DataConfig value, $Res Function(DataConfig) then) =
      _$DataConfigCopyWithImpl<$Res, DataConfig>;
  @useResult
  $Res call({List<String>? nomenclature, int? user});
}

/// @nodoc
class _$DataConfigCopyWithImpl<$Res, $Val extends DataConfig>
    implements $DataConfigCopyWith<$Res> {
  _$DataConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DataConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nomenclature = freezed,
    Object? user = freezed,
  }) {
    return _then(_value.copyWith(
      nomenclature: freezed == nomenclature
          ? _value.nomenclature
          : nomenclature // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DataConfigImplCopyWith<$Res>
    implements $DataConfigCopyWith<$Res> {
  factory _$$DataConfigImplCopyWith(
          _$DataConfigImpl value, $Res Function(_$DataConfigImpl) then) =
      __$$DataConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<String>? nomenclature, int? user});
}

/// @nodoc
class __$$DataConfigImplCopyWithImpl<$Res>
    extends _$DataConfigCopyWithImpl<$Res, _$DataConfigImpl>
    implements _$$DataConfigImplCopyWith<$Res> {
  __$$DataConfigImplCopyWithImpl(
      _$DataConfigImpl _value, $Res Function(_$DataConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of DataConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nomenclature = freezed,
    Object? user = freezed,
  }) {
    return _then(_$DataConfigImpl(
      nomenclature: freezed == nomenclature
          ? _value._nomenclature
          : nomenclature // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$DataConfigImpl implements _DataConfig {
  const _$DataConfigImpl({final List<String>? nomenclature, this.user})
      : _nomenclature = nomenclature;

  final List<String>? _nomenclature;
  @override
  List<String>? get nomenclature {
    final value = _nomenclature;
    if (value == null) return null;
    if (_nomenclature is EqualUnmodifiableListView) return _nomenclature;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? user;

  @override
  String toString() {
    return 'DataConfig(nomenclature: $nomenclature, user: $user)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataConfigImpl &&
            const DeepCollectionEquality()
                .equals(other._nomenclature, _nomenclature) &&
            (identical(other.user, user) || other.user == user));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_nomenclature), user);

  /// Create a copy of DataConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DataConfigImplCopyWith<_$DataConfigImpl> get copyWith =>
      __$$DataConfigImplCopyWithImpl<_$DataConfigImpl>(this, _$identity);
}

abstract class _DataConfig implements DataConfig {
  const factory _DataConfig(
      {final List<String>? nomenclature, final int? user}) = _$DataConfigImpl;

  @override
  List<String>? get nomenclature;
  @override
  int? get user;

  /// Create a copy of DataConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DataConfigImplCopyWith<_$DataConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ModuleConfig {
  @JsonKey(name: 'b_draw_sites_group')
  bool? get drawSitesGroup => throw _privateConstructorUsedError;
  @JsonKey(name: 'b_synthese')
  bool? get synthese => throw _privateConstructorUsedError;
  List<String>? get childrenTypes => throw _privateConstructorUsedError;
  String? get color => throw _privateConstructorUsedError;
  CruvedConfig? get cruved => throw _privateConstructorUsedError;
  String? get descriptionFieldName => throw _privateConstructorUsedError;
  List<String>? get displayForm => throw _privateConstructorUsedError;
  List<String>? get displayList => throw _privateConstructorUsedError;
  List<String>? get displayProperties => throw _privateConstructorUsedError;
  List<ExportConfig>? get exportCsv => throw _privateConstructorUsedError;
  List<ExportConfig>? get exportPdf => throw _privateConstructorUsedError;
  Map<String, dynamic>? get filters => throw _privateConstructorUsedError;
  Map<String, GenericFieldConfig>? get generic =>
      throw _privateConstructorUsedError;
  String? get genre => throw _privateConstructorUsedError;
  String? get idFieldName => throw _privateConstructorUsedError;
  int? get idListObserver => throw _privateConstructorUsedError;
  int? get idListTaxonomy => throw _privateConstructorUsedError;
  int? get idModule => throw _privateConstructorUsedError;
  int? get idTableLocation => throw _privateConstructorUsedError;
  String? get label => throw _privateConstructorUsedError;
  String? get moduleCode => throw _privateConstructorUsedError;
  String? get moduleDesc => throw _privateConstructorUsedError;
  String? get moduleLabel => throw _privateConstructorUsedError;
  List<String>? get parentTypes => throw _privateConstructorUsedError;
  List<String>? get propertiesKeys => throw _privateConstructorUsedError;
  bool? get rootObject => throw _privateConstructorUsedError;
  Map<String, dynamic>? get specific => throw _privateConstructorUsedError;
  String? get taxonomyDisplayFieldName => throw _privateConstructorUsedError;
  Map<String, TypeSiteConfig>? get typesSite =>
      throw _privateConstructorUsedError;
  String? get uuidFieldName => throw _privateConstructorUsedError;

  /// Create a copy of ModuleConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ModuleConfigCopyWith<ModuleConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModuleConfigCopyWith<$Res> {
  factory $ModuleConfigCopyWith(
          ModuleConfig value, $Res Function(ModuleConfig) then) =
      _$ModuleConfigCopyWithImpl<$Res, ModuleConfig>;
  @useResult
  $Res call(
      {@JsonKey(name: 'b_draw_sites_group') bool? drawSitesGroup,
      @JsonKey(name: 'b_synthese') bool? synthese,
      List<String>? childrenTypes,
      String? color,
      CruvedConfig? cruved,
      String? descriptionFieldName,
      List<String>? displayForm,
      List<String>? displayList,
      List<String>? displayProperties,
      List<ExportConfig>? exportCsv,
      List<ExportConfig>? exportPdf,
      Map<String, dynamic>? filters,
      Map<String, GenericFieldConfig>? generic,
      String? genre,
      String? idFieldName,
      int? idListObserver,
      int? idListTaxonomy,
      int? idModule,
      int? idTableLocation,
      String? label,
      String? moduleCode,
      String? moduleDesc,
      String? moduleLabel,
      List<String>? parentTypes,
      List<String>? propertiesKeys,
      bool? rootObject,
      Map<String, dynamic>? specific,
      String? taxonomyDisplayFieldName,
      Map<String, TypeSiteConfig>? typesSite,
      String? uuidFieldName});

  $CruvedConfigCopyWith<$Res>? get cruved;
}

/// @nodoc
class _$ModuleConfigCopyWithImpl<$Res, $Val extends ModuleConfig>
    implements $ModuleConfigCopyWith<$Res> {
  _$ModuleConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ModuleConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? drawSitesGroup = freezed,
    Object? synthese = freezed,
    Object? childrenTypes = freezed,
    Object? color = freezed,
    Object? cruved = freezed,
    Object? descriptionFieldName = freezed,
    Object? displayForm = freezed,
    Object? displayList = freezed,
    Object? displayProperties = freezed,
    Object? exportCsv = freezed,
    Object? exportPdf = freezed,
    Object? filters = freezed,
    Object? generic = freezed,
    Object? genre = freezed,
    Object? idFieldName = freezed,
    Object? idListObserver = freezed,
    Object? idListTaxonomy = freezed,
    Object? idModule = freezed,
    Object? idTableLocation = freezed,
    Object? label = freezed,
    Object? moduleCode = freezed,
    Object? moduleDesc = freezed,
    Object? moduleLabel = freezed,
    Object? parentTypes = freezed,
    Object? propertiesKeys = freezed,
    Object? rootObject = freezed,
    Object? specific = freezed,
    Object? taxonomyDisplayFieldName = freezed,
    Object? typesSite = freezed,
    Object? uuidFieldName = freezed,
  }) {
    return _then(_value.copyWith(
      drawSitesGroup: freezed == drawSitesGroup
          ? _value.drawSitesGroup
          : drawSitesGroup // ignore: cast_nullable_to_non_nullable
              as bool?,
      synthese: freezed == synthese
          ? _value.synthese
          : synthese // ignore: cast_nullable_to_non_nullable
              as bool?,
      childrenTypes: freezed == childrenTypes
          ? _value.childrenTypes
          : childrenTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
      cruved: freezed == cruved
          ? _value.cruved
          : cruved // ignore: cast_nullable_to_non_nullable
              as CruvedConfig?,
      descriptionFieldName: freezed == descriptionFieldName
          ? _value.descriptionFieldName
          : descriptionFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      displayForm: freezed == displayForm
          ? _value.displayForm
          : displayForm // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      displayList: freezed == displayList
          ? _value.displayList
          : displayList // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      displayProperties: freezed == displayProperties
          ? _value.displayProperties
          : displayProperties // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      exportCsv: freezed == exportCsv
          ? _value.exportCsv
          : exportCsv // ignore: cast_nullable_to_non_nullable
              as List<ExportConfig>?,
      exportPdf: freezed == exportPdf
          ? _value.exportPdf
          : exportPdf // ignore: cast_nullable_to_non_nullable
              as List<ExportConfig>?,
      filters: freezed == filters
          ? _value.filters
          : filters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      generic: freezed == generic
          ? _value.generic
          : generic // ignore: cast_nullable_to_non_nullable
              as Map<String, GenericFieldConfig>?,
      genre: freezed == genre
          ? _value.genre
          : genre // ignore: cast_nullable_to_non_nullable
              as String?,
      idFieldName: freezed == idFieldName
          ? _value.idFieldName
          : idFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      idListObserver: freezed == idListObserver
          ? _value.idListObserver
          : idListObserver // ignore: cast_nullable_to_non_nullable
              as int?,
      idListTaxonomy: freezed == idListTaxonomy
          ? _value.idListTaxonomy
          : idListTaxonomy // ignore: cast_nullable_to_non_nullable
              as int?,
      idModule: freezed == idModule
          ? _value.idModule
          : idModule // ignore: cast_nullable_to_non_nullable
              as int?,
      idTableLocation: freezed == idTableLocation
          ? _value.idTableLocation
          : idTableLocation // ignore: cast_nullable_to_non_nullable
              as int?,
      label: freezed == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String?,
      moduleCode: freezed == moduleCode
          ? _value.moduleCode
          : moduleCode // ignore: cast_nullable_to_non_nullable
              as String?,
      moduleDesc: freezed == moduleDesc
          ? _value.moduleDesc
          : moduleDesc // ignore: cast_nullable_to_non_nullable
              as String?,
      moduleLabel: freezed == moduleLabel
          ? _value.moduleLabel
          : moduleLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      parentTypes: freezed == parentTypes
          ? _value.parentTypes
          : parentTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      propertiesKeys: freezed == propertiesKeys
          ? _value.propertiesKeys
          : propertiesKeys // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      rootObject: freezed == rootObject
          ? _value.rootObject
          : rootObject // ignore: cast_nullable_to_non_nullable
              as bool?,
      specific: freezed == specific
          ? _value.specific
          : specific // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      taxonomyDisplayFieldName: freezed == taxonomyDisplayFieldName
          ? _value.taxonomyDisplayFieldName
          : taxonomyDisplayFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      typesSite: freezed == typesSite
          ? _value.typesSite
          : typesSite // ignore: cast_nullable_to_non_nullable
              as Map<String, TypeSiteConfig>?,
      uuidFieldName: freezed == uuidFieldName
          ? _value.uuidFieldName
          : uuidFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of ModuleConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CruvedConfigCopyWith<$Res>? get cruved {
    if (_value.cruved == null) {
      return null;
    }

    return $CruvedConfigCopyWith<$Res>(_value.cruved!, (value) {
      return _then(_value.copyWith(cruved: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ModuleConfigImplCopyWith<$Res>
    implements $ModuleConfigCopyWith<$Res> {
  factory _$$ModuleConfigImplCopyWith(
          _$ModuleConfigImpl value, $Res Function(_$ModuleConfigImpl) then) =
      __$$ModuleConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'b_draw_sites_group') bool? drawSitesGroup,
      @JsonKey(name: 'b_synthese') bool? synthese,
      List<String>? childrenTypes,
      String? color,
      CruvedConfig? cruved,
      String? descriptionFieldName,
      List<String>? displayForm,
      List<String>? displayList,
      List<String>? displayProperties,
      List<ExportConfig>? exportCsv,
      List<ExportConfig>? exportPdf,
      Map<String, dynamic>? filters,
      Map<String, GenericFieldConfig>? generic,
      String? genre,
      String? idFieldName,
      int? idListObserver,
      int? idListTaxonomy,
      int? idModule,
      int? idTableLocation,
      String? label,
      String? moduleCode,
      String? moduleDesc,
      String? moduleLabel,
      List<String>? parentTypes,
      List<String>? propertiesKeys,
      bool? rootObject,
      Map<String, dynamic>? specific,
      String? taxonomyDisplayFieldName,
      Map<String, TypeSiteConfig>? typesSite,
      String? uuidFieldName});

  @override
  $CruvedConfigCopyWith<$Res>? get cruved;
}

/// @nodoc
class __$$ModuleConfigImplCopyWithImpl<$Res>
    extends _$ModuleConfigCopyWithImpl<$Res, _$ModuleConfigImpl>
    implements _$$ModuleConfigImplCopyWith<$Res> {
  __$$ModuleConfigImplCopyWithImpl(
      _$ModuleConfigImpl _value, $Res Function(_$ModuleConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of ModuleConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? drawSitesGroup = freezed,
    Object? synthese = freezed,
    Object? childrenTypes = freezed,
    Object? color = freezed,
    Object? cruved = freezed,
    Object? descriptionFieldName = freezed,
    Object? displayForm = freezed,
    Object? displayList = freezed,
    Object? displayProperties = freezed,
    Object? exportCsv = freezed,
    Object? exportPdf = freezed,
    Object? filters = freezed,
    Object? generic = freezed,
    Object? genre = freezed,
    Object? idFieldName = freezed,
    Object? idListObserver = freezed,
    Object? idListTaxonomy = freezed,
    Object? idModule = freezed,
    Object? idTableLocation = freezed,
    Object? label = freezed,
    Object? moduleCode = freezed,
    Object? moduleDesc = freezed,
    Object? moduleLabel = freezed,
    Object? parentTypes = freezed,
    Object? propertiesKeys = freezed,
    Object? rootObject = freezed,
    Object? specific = freezed,
    Object? taxonomyDisplayFieldName = freezed,
    Object? typesSite = freezed,
    Object? uuidFieldName = freezed,
  }) {
    return _then(_$ModuleConfigImpl(
      drawSitesGroup: freezed == drawSitesGroup
          ? _value.drawSitesGroup
          : drawSitesGroup // ignore: cast_nullable_to_non_nullable
              as bool?,
      synthese: freezed == synthese
          ? _value.synthese
          : synthese // ignore: cast_nullable_to_non_nullable
              as bool?,
      childrenTypes: freezed == childrenTypes
          ? _value._childrenTypes
          : childrenTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
      cruved: freezed == cruved
          ? _value.cruved
          : cruved // ignore: cast_nullable_to_non_nullable
              as CruvedConfig?,
      descriptionFieldName: freezed == descriptionFieldName
          ? _value.descriptionFieldName
          : descriptionFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      displayForm: freezed == displayForm
          ? _value._displayForm
          : displayForm // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      displayList: freezed == displayList
          ? _value._displayList
          : displayList // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      displayProperties: freezed == displayProperties
          ? _value._displayProperties
          : displayProperties // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      exportCsv: freezed == exportCsv
          ? _value._exportCsv
          : exportCsv // ignore: cast_nullable_to_non_nullable
              as List<ExportConfig>?,
      exportPdf: freezed == exportPdf
          ? _value._exportPdf
          : exportPdf // ignore: cast_nullable_to_non_nullable
              as List<ExportConfig>?,
      filters: freezed == filters
          ? _value._filters
          : filters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      generic: freezed == generic
          ? _value._generic
          : generic // ignore: cast_nullable_to_non_nullable
              as Map<String, GenericFieldConfig>?,
      genre: freezed == genre
          ? _value.genre
          : genre // ignore: cast_nullable_to_non_nullable
              as String?,
      idFieldName: freezed == idFieldName
          ? _value.idFieldName
          : idFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      idListObserver: freezed == idListObserver
          ? _value.idListObserver
          : idListObserver // ignore: cast_nullable_to_non_nullable
              as int?,
      idListTaxonomy: freezed == idListTaxonomy
          ? _value.idListTaxonomy
          : idListTaxonomy // ignore: cast_nullable_to_non_nullable
              as int?,
      idModule: freezed == idModule
          ? _value.idModule
          : idModule // ignore: cast_nullable_to_non_nullable
              as int?,
      idTableLocation: freezed == idTableLocation
          ? _value.idTableLocation
          : idTableLocation // ignore: cast_nullable_to_non_nullable
              as int?,
      label: freezed == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String?,
      moduleCode: freezed == moduleCode
          ? _value.moduleCode
          : moduleCode // ignore: cast_nullable_to_non_nullable
              as String?,
      moduleDesc: freezed == moduleDesc
          ? _value.moduleDesc
          : moduleDesc // ignore: cast_nullable_to_non_nullable
              as String?,
      moduleLabel: freezed == moduleLabel
          ? _value.moduleLabel
          : moduleLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      parentTypes: freezed == parentTypes
          ? _value._parentTypes
          : parentTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      propertiesKeys: freezed == propertiesKeys
          ? _value._propertiesKeys
          : propertiesKeys // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      rootObject: freezed == rootObject
          ? _value.rootObject
          : rootObject // ignore: cast_nullable_to_non_nullable
              as bool?,
      specific: freezed == specific
          ? _value._specific
          : specific // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      taxonomyDisplayFieldName: freezed == taxonomyDisplayFieldName
          ? _value.taxonomyDisplayFieldName
          : taxonomyDisplayFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      typesSite: freezed == typesSite
          ? _value._typesSite
          : typesSite // ignore: cast_nullable_to_non_nullable
              as Map<String, TypeSiteConfig>?,
      uuidFieldName: freezed == uuidFieldName
          ? _value.uuidFieldName
          : uuidFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ModuleConfigImpl implements _ModuleConfig {
  const _$ModuleConfigImpl(
      {@JsonKey(name: 'b_draw_sites_group') this.drawSitesGroup,
      @JsonKey(name: 'b_synthese') this.synthese,
      final List<String>? childrenTypes,
      this.color,
      this.cruved,
      this.descriptionFieldName,
      final List<String>? displayForm,
      final List<String>? displayList,
      final List<String>? displayProperties,
      final List<ExportConfig>? exportCsv,
      final List<ExportConfig>? exportPdf,
      final Map<String, dynamic>? filters,
      final Map<String, GenericFieldConfig>? generic,
      this.genre,
      this.idFieldName,
      this.idListObserver,
      this.idListTaxonomy,
      this.idModule,
      this.idTableLocation,
      this.label,
      this.moduleCode,
      this.moduleDesc,
      this.moduleLabel,
      final List<String>? parentTypes,
      final List<String>? propertiesKeys,
      this.rootObject,
      final Map<String, dynamic>? specific,
      this.taxonomyDisplayFieldName,
      final Map<String, TypeSiteConfig>? typesSite,
      this.uuidFieldName})
      : _childrenTypes = childrenTypes,
        _displayForm = displayForm,
        _displayList = displayList,
        _displayProperties = displayProperties,
        _exportCsv = exportCsv,
        _exportPdf = exportPdf,
        _filters = filters,
        _generic = generic,
        _parentTypes = parentTypes,
        _propertiesKeys = propertiesKeys,
        _specific = specific,
        _typesSite = typesSite;

  @override
  @JsonKey(name: 'b_draw_sites_group')
  final bool? drawSitesGroup;
  @override
  @JsonKey(name: 'b_synthese')
  final bool? synthese;
  final List<String>? _childrenTypes;
  @override
  List<String>? get childrenTypes {
    final value = _childrenTypes;
    if (value == null) return null;
    if (_childrenTypes is EqualUnmodifiableListView) return _childrenTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? color;
  @override
  final CruvedConfig? cruved;
  @override
  final String? descriptionFieldName;
  final List<String>? _displayForm;
  @override
  List<String>? get displayForm {
    final value = _displayForm;
    if (value == null) return null;
    if (_displayForm is EqualUnmodifiableListView) return _displayForm;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _displayList;
  @override
  List<String>? get displayList {
    final value = _displayList;
    if (value == null) return null;
    if (_displayList is EqualUnmodifiableListView) return _displayList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _displayProperties;
  @override
  List<String>? get displayProperties {
    final value = _displayProperties;
    if (value == null) return null;
    if (_displayProperties is EqualUnmodifiableListView)
      return _displayProperties;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<ExportConfig>? _exportCsv;
  @override
  List<ExportConfig>? get exportCsv {
    final value = _exportCsv;
    if (value == null) return null;
    if (_exportCsv is EqualUnmodifiableListView) return _exportCsv;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<ExportConfig>? _exportPdf;
  @override
  List<ExportConfig>? get exportPdf {
    final value = _exportPdf;
    if (value == null) return null;
    if (_exportPdf is EqualUnmodifiableListView) return _exportPdf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final Map<String, dynamic>? _filters;
  @override
  Map<String, dynamic>? get filters {
    final value = _filters;
    if (value == null) return null;
    if (_filters is EqualUnmodifiableMapView) return _filters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, GenericFieldConfig>? _generic;
  @override
  Map<String, GenericFieldConfig>? get generic {
    final value = _generic;
    if (value == null) return null;
    if (_generic is EqualUnmodifiableMapView) return _generic;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? genre;
  @override
  final String? idFieldName;
  @override
  final int? idListObserver;
  @override
  final int? idListTaxonomy;
  @override
  final int? idModule;
  @override
  final int? idTableLocation;
  @override
  final String? label;
  @override
  final String? moduleCode;
  @override
  final String? moduleDesc;
  @override
  final String? moduleLabel;
  final List<String>? _parentTypes;
  @override
  List<String>? get parentTypes {
    final value = _parentTypes;
    if (value == null) return null;
    if (_parentTypes is EqualUnmodifiableListView) return _parentTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _propertiesKeys;
  @override
  List<String>? get propertiesKeys {
    final value = _propertiesKeys;
    if (value == null) return null;
    if (_propertiesKeys is EqualUnmodifiableListView) return _propertiesKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool? rootObject;
  final Map<String, dynamic>? _specific;
  @override
  Map<String, dynamic>? get specific {
    final value = _specific;
    if (value == null) return null;
    if (_specific is EqualUnmodifiableMapView) return _specific;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? taxonomyDisplayFieldName;
  final Map<String, TypeSiteConfig>? _typesSite;
  @override
  Map<String, TypeSiteConfig>? get typesSite {
    final value = _typesSite;
    if (value == null) return null;
    if (_typesSite is EqualUnmodifiableMapView) return _typesSite;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? uuidFieldName;

  @override
  String toString() {
    return 'ModuleConfig(drawSitesGroup: $drawSitesGroup, synthese: $synthese, childrenTypes: $childrenTypes, color: $color, cruved: $cruved, descriptionFieldName: $descriptionFieldName, displayForm: $displayForm, displayList: $displayList, displayProperties: $displayProperties, exportCsv: $exportCsv, exportPdf: $exportPdf, filters: $filters, generic: $generic, genre: $genre, idFieldName: $idFieldName, idListObserver: $idListObserver, idListTaxonomy: $idListTaxonomy, idModule: $idModule, idTableLocation: $idTableLocation, label: $label, moduleCode: $moduleCode, moduleDesc: $moduleDesc, moduleLabel: $moduleLabel, parentTypes: $parentTypes, propertiesKeys: $propertiesKeys, rootObject: $rootObject, specific: $specific, taxonomyDisplayFieldName: $taxonomyDisplayFieldName, typesSite: $typesSite, uuidFieldName: $uuidFieldName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ModuleConfigImpl &&
            (identical(other.drawSitesGroup, drawSitesGroup) ||
                other.drawSitesGroup == drawSitesGroup) &&
            (identical(other.synthese, synthese) ||
                other.synthese == synthese) &&
            const DeepCollectionEquality()
                .equals(other._childrenTypes, _childrenTypes) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.cruved, cruved) || other.cruved == cruved) &&
            (identical(other.descriptionFieldName, descriptionFieldName) ||
                other.descriptionFieldName == descriptionFieldName) &&
            const DeepCollectionEquality()
                .equals(other._displayForm, _displayForm) &&
            const DeepCollectionEquality()
                .equals(other._displayList, _displayList) &&
            const DeepCollectionEquality()
                .equals(other._displayProperties, _displayProperties) &&
            const DeepCollectionEquality()
                .equals(other._exportCsv, _exportCsv) &&
            const DeepCollectionEquality()
                .equals(other._exportPdf, _exportPdf) &&
            const DeepCollectionEquality().equals(other._filters, _filters) &&
            const DeepCollectionEquality().equals(other._generic, _generic) &&
            (identical(other.genre, genre) || other.genre == genre) &&
            (identical(other.idFieldName, idFieldName) ||
                other.idFieldName == idFieldName) &&
            (identical(other.idListObserver, idListObserver) ||
                other.idListObserver == idListObserver) &&
            (identical(other.idListTaxonomy, idListTaxonomy) ||
                other.idListTaxonomy == idListTaxonomy) &&
            (identical(other.idModule, idModule) ||
                other.idModule == idModule) &&
            (identical(other.idTableLocation, idTableLocation) ||
                other.idTableLocation == idTableLocation) &&
            (identical(other.label, label) || other.label == label) &&
            (identical(other.moduleCode, moduleCode) ||
                other.moduleCode == moduleCode) &&
            (identical(other.moduleDesc, moduleDesc) ||
                other.moduleDesc == moduleDesc) &&
            (identical(other.moduleLabel, moduleLabel) ||
                other.moduleLabel == moduleLabel) &&
            const DeepCollectionEquality()
                .equals(other._parentTypes, _parentTypes) &&
            const DeepCollectionEquality()
                .equals(other._propertiesKeys, _propertiesKeys) &&
            (identical(other.rootObject, rootObject) ||
                other.rootObject == rootObject) &&
            const DeepCollectionEquality().equals(other._specific, _specific) &&
            (identical(
                    other.taxonomyDisplayFieldName, taxonomyDisplayFieldName) ||
                other.taxonomyDisplayFieldName == taxonomyDisplayFieldName) &&
            const DeepCollectionEquality()
                .equals(other._typesSite, _typesSite) &&
            (identical(other.uuidFieldName, uuidFieldName) ||
                other.uuidFieldName == uuidFieldName));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        drawSitesGroup,
        synthese,
        const DeepCollectionEquality().hash(_childrenTypes),
        color,
        cruved,
        descriptionFieldName,
        const DeepCollectionEquality().hash(_displayForm),
        const DeepCollectionEquality().hash(_displayList),
        const DeepCollectionEquality().hash(_displayProperties),
        const DeepCollectionEquality().hash(_exportCsv),
        const DeepCollectionEquality().hash(_exportPdf),
        const DeepCollectionEquality().hash(_filters),
        const DeepCollectionEquality().hash(_generic),
        genre,
        idFieldName,
        idListObserver,
        idListTaxonomy,
        idModule,
        idTableLocation,
        label,
        moduleCode,
        moduleDesc,
        moduleLabel,
        const DeepCollectionEquality().hash(_parentTypes),
        const DeepCollectionEquality().hash(_propertiesKeys),
        rootObject,
        const DeepCollectionEquality().hash(_specific),
        taxonomyDisplayFieldName,
        const DeepCollectionEquality().hash(_typesSite),
        uuidFieldName
      ]);

  /// Create a copy of ModuleConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ModuleConfigImplCopyWith<_$ModuleConfigImpl> get copyWith =>
      __$$ModuleConfigImplCopyWithImpl<_$ModuleConfigImpl>(this, _$identity);
}

abstract class _ModuleConfig implements ModuleConfig {
  const factory _ModuleConfig(
      {@JsonKey(name: 'b_draw_sites_group') final bool? drawSitesGroup,
      @JsonKey(name: 'b_synthese') final bool? synthese,
      final List<String>? childrenTypes,
      final String? color,
      final CruvedConfig? cruved,
      final String? descriptionFieldName,
      final List<String>? displayForm,
      final List<String>? displayList,
      final List<String>? displayProperties,
      final List<ExportConfig>? exportCsv,
      final List<ExportConfig>? exportPdf,
      final Map<String, dynamic>? filters,
      final Map<String, GenericFieldConfig>? generic,
      final String? genre,
      final String? idFieldName,
      final int? idListObserver,
      final int? idListTaxonomy,
      final int? idModule,
      final int? idTableLocation,
      final String? label,
      final String? moduleCode,
      final String? moduleDesc,
      final String? moduleLabel,
      final List<String>? parentTypes,
      final List<String>? propertiesKeys,
      final bool? rootObject,
      final Map<String, dynamic>? specific,
      final String? taxonomyDisplayFieldName,
      final Map<String, TypeSiteConfig>? typesSite,
      final String? uuidFieldName}) = _$ModuleConfigImpl;

  @override
  @JsonKey(name: 'b_draw_sites_group')
  bool? get drawSitesGroup;
  @override
  @JsonKey(name: 'b_synthese')
  bool? get synthese;
  @override
  List<String>? get childrenTypes;
  @override
  String? get color;
  @override
  CruvedConfig? get cruved;
  @override
  String? get descriptionFieldName;
  @override
  List<String>? get displayForm;
  @override
  List<String>? get displayList;
  @override
  List<String>? get displayProperties;
  @override
  List<ExportConfig>? get exportCsv;
  @override
  List<ExportConfig>? get exportPdf;
  @override
  Map<String, dynamic>? get filters;
  @override
  Map<String, GenericFieldConfig>? get generic;
  @override
  String? get genre;
  @override
  String? get idFieldName;
  @override
  int? get idListObserver;
  @override
  int? get idListTaxonomy;
  @override
  int? get idModule;
  @override
  int? get idTableLocation;
  @override
  String? get label;
  @override
  String? get moduleCode;
  @override
  String? get moduleDesc;
  @override
  String? get moduleLabel;
  @override
  List<String>? get parentTypes;
  @override
  List<String>? get propertiesKeys;
  @override
  bool? get rootObject;
  @override
  Map<String, dynamic>? get specific;
  @override
  String? get taxonomyDisplayFieldName;
  @override
  Map<String, TypeSiteConfig>? get typesSite;
  @override
  String? get uuidFieldName;

  /// Create a copy of ModuleConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ModuleConfigImplCopyWith<_$ModuleConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CruvedConfig {
  int? get C => throw _privateConstructorUsedError;
  int? get R => throw _privateConstructorUsedError;
  int? get U => throw _privateConstructorUsedError;
  int? get V => throw _privateConstructorUsedError;
  int? get E => throw _privateConstructorUsedError;
  int? get D => throw _privateConstructorUsedError;

  /// Create a copy of CruvedConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CruvedConfigCopyWith<CruvedConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CruvedConfigCopyWith<$Res> {
  factory $CruvedConfigCopyWith(
          CruvedConfig value, $Res Function(CruvedConfig) then) =
      _$CruvedConfigCopyWithImpl<$Res, CruvedConfig>;
  @useResult
  $Res call({int? C, int? R, int? U, int? V, int? E, int? D});
}

/// @nodoc
class _$CruvedConfigCopyWithImpl<$Res, $Val extends CruvedConfig>
    implements $CruvedConfigCopyWith<$Res> {
  _$CruvedConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CruvedConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? C = freezed,
    Object? R = freezed,
    Object? U = freezed,
    Object? V = freezed,
    Object? E = freezed,
    Object? D = freezed,
  }) {
    return _then(_value.copyWith(
      C: freezed == C
          ? _value.C
          : C // ignore: cast_nullable_to_non_nullable
              as int?,
      R: freezed == R
          ? _value.R
          : R // ignore: cast_nullable_to_non_nullable
              as int?,
      U: freezed == U
          ? _value.U
          : U // ignore: cast_nullable_to_non_nullable
              as int?,
      V: freezed == V
          ? _value.V
          : V // ignore: cast_nullable_to_non_nullable
              as int?,
      E: freezed == E
          ? _value.E
          : E // ignore: cast_nullable_to_non_nullable
              as int?,
      D: freezed == D
          ? _value.D
          : D // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CruvedConfigImplCopyWith<$Res>
    implements $CruvedConfigCopyWith<$Res> {
  factory _$$CruvedConfigImplCopyWith(
          _$CruvedConfigImpl value, $Res Function(_$CruvedConfigImpl) then) =
      __$$CruvedConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? C, int? R, int? U, int? V, int? E, int? D});
}

/// @nodoc
class __$$CruvedConfigImplCopyWithImpl<$Res>
    extends _$CruvedConfigCopyWithImpl<$Res, _$CruvedConfigImpl>
    implements _$$CruvedConfigImplCopyWith<$Res> {
  __$$CruvedConfigImplCopyWithImpl(
      _$CruvedConfigImpl _value, $Res Function(_$CruvedConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of CruvedConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? C = freezed,
    Object? R = freezed,
    Object? U = freezed,
    Object? V = freezed,
    Object? E = freezed,
    Object? D = freezed,
  }) {
    return _then(_$CruvedConfigImpl(
      C: freezed == C
          ? _value.C
          : C // ignore: cast_nullable_to_non_nullable
              as int?,
      R: freezed == R
          ? _value.R
          : R // ignore: cast_nullable_to_non_nullable
              as int?,
      U: freezed == U
          ? _value.U
          : U // ignore: cast_nullable_to_non_nullable
              as int?,
      V: freezed == V
          ? _value.V
          : V // ignore: cast_nullable_to_non_nullable
              as int?,
      E: freezed == E
          ? _value.E
          : E // ignore: cast_nullable_to_non_nullable
              as int?,
      D: freezed == D
          ? _value.D
          : D // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$CruvedConfigImpl implements _CruvedConfig {
  const _$CruvedConfigImpl({this.C, this.R, this.U, this.V, this.E, this.D});

  @override
  final int? C;
  @override
  final int? R;
  @override
  final int? U;
  @override
  final int? V;
  @override
  final int? E;
  @override
  final int? D;

  @override
  String toString() {
    return 'CruvedConfig(C: $C, R: $R, U: $U, V: $V, E: $E, D: $D)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CruvedConfigImpl &&
            (identical(other.C, C) || other.C == C) &&
            (identical(other.R, R) || other.R == R) &&
            (identical(other.U, U) || other.U == U) &&
            (identical(other.V, V) || other.V == V) &&
            (identical(other.E, E) || other.E == E) &&
            (identical(other.D, D) || other.D == D));
  }

  @override
  int get hashCode => Object.hash(runtimeType, C, R, U, V, E, D);

  /// Create a copy of CruvedConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CruvedConfigImplCopyWith<_$CruvedConfigImpl> get copyWith =>
      __$$CruvedConfigImplCopyWithImpl<_$CruvedConfigImpl>(this, _$identity);
}

abstract class _CruvedConfig implements CruvedConfig {
  const factory _CruvedConfig(
      {final int? C,
      final int? R,
      final int? U,
      final int? V,
      final int? E,
      final int? D}) = _$CruvedConfigImpl;

  @override
  int? get C;
  @override
  int? get R;
  @override
  int? get U;
  @override
  int? get V;
  @override
  int? get E;
  @override
  int? get D;

  /// Create a copy of CruvedConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CruvedConfigImplCopyWith<_$CruvedConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ExportConfig {
  String? get label => throw _privateConstructorUsedError;
  String? get method => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  String? get template => throw _privateConstructorUsedError;

  /// Create a copy of ExportConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ExportConfigCopyWith<ExportConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExportConfigCopyWith<$Res> {
  factory $ExportConfigCopyWith(
          ExportConfig value, $Res Function(ExportConfig) then) =
      _$ExportConfigCopyWithImpl<$Res, ExportConfig>;
  @useResult
  $Res call({String? label, String? method, String? type, String? template});
}

/// @nodoc
class _$ExportConfigCopyWithImpl<$Res, $Val extends ExportConfig>
    implements $ExportConfigCopyWith<$Res> {
  _$ExportConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ExportConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? label = freezed,
    Object? method = freezed,
    Object? type = freezed,
    Object? template = freezed,
  }) {
    return _then(_value.copyWith(
      label: freezed == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String?,
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      template: freezed == template
          ? _value.template
          : template // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExportConfigImplCopyWith<$Res>
    implements $ExportConfigCopyWith<$Res> {
  factory _$$ExportConfigImplCopyWith(
          _$ExportConfigImpl value, $Res Function(_$ExportConfigImpl) then) =
      __$$ExportConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? label, String? method, String? type, String? template});
}

/// @nodoc
class __$$ExportConfigImplCopyWithImpl<$Res>
    extends _$ExportConfigCopyWithImpl<$Res, _$ExportConfigImpl>
    implements _$$ExportConfigImplCopyWith<$Res> {
  __$$ExportConfigImplCopyWithImpl(
      _$ExportConfigImpl _value, $Res Function(_$ExportConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExportConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? label = freezed,
    Object? method = freezed,
    Object? type = freezed,
    Object? template = freezed,
  }) {
    return _then(_$ExportConfigImpl(
      label: freezed == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String?,
      method: freezed == method
          ? _value.method
          : method // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      template: freezed == template
          ? _value.template
          : template // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ExportConfigImpl implements _ExportConfig {
  const _$ExportConfigImpl({this.label, this.method, this.type, this.template});

  @override
  final String? label;
  @override
  final String? method;
  @override
  final String? type;
  @override
  final String? template;

  @override
  String toString() {
    return 'ExportConfig(label: $label, method: $method, type: $type, template: $template)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExportConfigImpl &&
            (identical(other.label, label) || other.label == label) &&
            (identical(other.method, method) || other.method == method) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.template, template) ||
                other.template == template));
  }

  @override
  int get hashCode => Object.hash(runtimeType, label, method, type, template);

  /// Create a copy of ExportConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExportConfigImplCopyWith<_$ExportConfigImpl> get copyWith =>
      __$$ExportConfigImplCopyWithImpl<_$ExportConfigImpl>(this, _$identity);
}

abstract class _ExportConfig implements ExportConfig {
  const factory _ExportConfig(
      {final String? label,
      final String? method,
      final String? type,
      final String? template}) = _$ExportConfigImpl;

  @override
  String? get label;
  @override
  String? get method;
  @override
  String? get type;
  @override
  String? get template;

  /// Create a copy of ExportConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExportConfigImplCopyWith<_$ExportConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GenericFieldConfig {
  @JsonKey(name: 'attribut_label')
  String? get attributLabel => throw _privateConstructorUsedError;
  String? get definition => throw _privateConstructorUsedError;
  bool? get hidden => throw _privateConstructorUsedError;
  bool? get required => throw _privateConstructorUsedError;
  String? get typeWidget => throw _privateConstructorUsedError;
  String? get typeUtil => throw _privateConstructorUsedError;
  bool? get multiSelect => throw _privateConstructorUsedError;
  String? get api => throw _privateConstructorUsedError;
  String? get application => throw _privateConstructorUsedError;
  String? get keyLabel => throw _privateConstructorUsedError;
  String? get keyValue => throw _privateConstructorUsedError;
  bool? get multiple => throw _privateConstructorUsedError;
  List<Map<String, dynamic>>? get values => throw _privateConstructorUsedError;
  Map<String, dynamic>? get default_ => throw _privateConstructorUsedError;
  String? get designStyle => throw _privateConstructorUsedError;
  String? get dataPath => throw _privateConstructorUsedError;

  /// Create a copy of GenericFieldConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GenericFieldConfigCopyWith<GenericFieldConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GenericFieldConfigCopyWith<$Res> {
  factory $GenericFieldConfigCopyWith(
          GenericFieldConfig value, $Res Function(GenericFieldConfig) then) =
      _$GenericFieldConfigCopyWithImpl<$Res, GenericFieldConfig>;
  @useResult
  $Res call(
      {@JsonKey(name: 'attribut_label') String? attributLabel,
      String? definition,
      bool? hidden,
      bool? required,
      String? typeWidget,
      String? typeUtil,
      bool? multiSelect,
      String? api,
      String? application,
      String? keyLabel,
      String? keyValue,
      bool? multiple,
      List<Map<String, dynamic>>? values,
      Map<String, dynamic>? default_,
      String? designStyle,
      String? dataPath});
}

/// @nodoc
class _$GenericFieldConfigCopyWithImpl<$Res, $Val extends GenericFieldConfig>
    implements $GenericFieldConfigCopyWith<$Res> {
  _$GenericFieldConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GenericFieldConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? attributLabel = freezed,
    Object? definition = freezed,
    Object? hidden = freezed,
    Object? required = freezed,
    Object? typeWidget = freezed,
    Object? typeUtil = freezed,
    Object? multiSelect = freezed,
    Object? api = freezed,
    Object? application = freezed,
    Object? keyLabel = freezed,
    Object? keyValue = freezed,
    Object? multiple = freezed,
    Object? values = freezed,
    Object? default_ = freezed,
    Object? designStyle = freezed,
    Object? dataPath = freezed,
  }) {
    return _then(_value.copyWith(
      attributLabel: freezed == attributLabel
          ? _value.attributLabel
          : attributLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      definition: freezed == definition
          ? _value.definition
          : definition // ignore: cast_nullable_to_non_nullable
              as String?,
      hidden: freezed == hidden
          ? _value.hidden
          : hidden // ignore: cast_nullable_to_non_nullable
              as bool?,
      required: freezed == required
          ? _value.required
          : required // ignore: cast_nullable_to_non_nullable
              as bool?,
      typeWidget: freezed == typeWidget
          ? _value.typeWidget
          : typeWidget // ignore: cast_nullable_to_non_nullable
              as String?,
      typeUtil: freezed == typeUtil
          ? _value.typeUtil
          : typeUtil // ignore: cast_nullable_to_non_nullable
              as String?,
      multiSelect: freezed == multiSelect
          ? _value.multiSelect
          : multiSelect // ignore: cast_nullable_to_non_nullable
              as bool?,
      api: freezed == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String?,
      application: freezed == application
          ? _value.application
          : application // ignore: cast_nullable_to_non_nullable
              as String?,
      keyLabel: freezed == keyLabel
          ? _value.keyLabel
          : keyLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      keyValue: freezed == keyValue
          ? _value.keyValue
          : keyValue // ignore: cast_nullable_to_non_nullable
              as String?,
      multiple: freezed == multiple
          ? _value.multiple
          : multiple // ignore: cast_nullable_to_non_nullable
              as bool?,
      values: freezed == values
          ? _value.values
          : values // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>?,
      default_: freezed == default_
          ? _value.default_
          : default_ // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      designStyle: freezed == designStyle
          ? _value.designStyle
          : designStyle // ignore: cast_nullable_to_non_nullable
              as String?,
      dataPath: freezed == dataPath
          ? _value.dataPath
          : dataPath // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GenericFieldConfigImplCopyWith<$Res>
    implements $GenericFieldConfigCopyWith<$Res> {
  factory _$$GenericFieldConfigImplCopyWith(_$GenericFieldConfigImpl value,
          $Res Function(_$GenericFieldConfigImpl) then) =
      __$$GenericFieldConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'attribut_label') String? attributLabel,
      String? definition,
      bool? hidden,
      bool? required,
      String? typeWidget,
      String? typeUtil,
      bool? multiSelect,
      String? api,
      String? application,
      String? keyLabel,
      String? keyValue,
      bool? multiple,
      List<Map<String, dynamic>>? values,
      Map<String, dynamic>? default_,
      String? designStyle,
      String? dataPath});
}

/// @nodoc
class __$$GenericFieldConfigImplCopyWithImpl<$Res>
    extends _$GenericFieldConfigCopyWithImpl<$Res, _$GenericFieldConfigImpl>
    implements _$$GenericFieldConfigImplCopyWith<$Res> {
  __$$GenericFieldConfigImplCopyWithImpl(_$GenericFieldConfigImpl _value,
      $Res Function(_$GenericFieldConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of GenericFieldConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? attributLabel = freezed,
    Object? definition = freezed,
    Object? hidden = freezed,
    Object? required = freezed,
    Object? typeWidget = freezed,
    Object? typeUtil = freezed,
    Object? multiSelect = freezed,
    Object? api = freezed,
    Object? application = freezed,
    Object? keyLabel = freezed,
    Object? keyValue = freezed,
    Object? multiple = freezed,
    Object? values = freezed,
    Object? default_ = freezed,
    Object? designStyle = freezed,
    Object? dataPath = freezed,
  }) {
    return _then(_$GenericFieldConfigImpl(
      attributLabel: freezed == attributLabel
          ? _value.attributLabel
          : attributLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      definition: freezed == definition
          ? _value.definition
          : definition // ignore: cast_nullable_to_non_nullable
              as String?,
      hidden: freezed == hidden
          ? _value.hidden
          : hidden // ignore: cast_nullable_to_non_nullable
              as bool?,
      required: freezed == required
          ? _value.required
          : required // ignore: cast_nullable_to_non_nullable
              as bool?,
      typeWidget: freezed == typeWidget
          ? _value.typeWidget
          : typeWidget // ignore: cast_nullable_to_non_nullable
              as String?,
      typeUtil: freezed == typeUtil
          ? _value.typeUtil
          : typeUtil // ignore: cast_nullable_to_non_nullable
              as String?,
      multiSelect: freezed == multiSelect
          ? _value.multiSelect
          : multiSelect // ignore: cast_nullable_to_non_nullable
              as bool?,
      api: freezed == api
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String?,
      application: freezed == application
          ? _value.application
          : application // ignore: cast_nullable_to_non_nullable
              as String?,
      keyLabel: freezed == keyLabel
          ? _value.keyLabel
          : keyLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      keyValue: freezed == keyValue
          ? _value.keyValue
          : keyValue // ignore: cast_nullable_to_non_nullable
              as String?,
      multiple: freezed == multiple
          ? _value.multiple
          : multiple // ignore: cast_nullable_to_non_nullable
              as bool?,
      values: freezed == values
          ? _value._values
          : values // ignore: cast_nullable_to_non_nullable
              as List<Map<String, dynamic>>?,
      default_: freezed == default_
          ? _value._default_
          : default_ // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      designStyle: freezed == designStyle
          ? _value.designStyle
          : designStyle // ignore: cast_nullable_to_non_nullable
              as String?,
      dataPath: freezed == dataPath
          ? _value.dataPath
          : dataPath // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$GenericFieldConfigImpl implements _GenericFieldConfig {
  const _$GenericFieldConfigImpl(
      {@JsonKey(name: 'attribut_label') this.attributLabel,
      this.definition,
      this.hidden,
      this.required,
      this.typeWidget,
      this.typeUtil,
      this.multiSelect,
      this.api,
      this.application,
      this.keyLabel,
      this.keyValue,
      this.multiple,
      final List<Map<String, dynamic>>? values,
      final Map<String, dynamic>? default_,
      this.designStyle,
      this.dataPath})
      : _values = values,
        _default_ = default_;

  @override
  @JsonKey(name: 'attribut_label')
  final String? attributLabel;
  @override
  final String? definition;
  @override
  final bool? hidden;
  @override
  final bool? required;
  @override
  final String? typeWidget;
  @override
  final String? typeUtil;
  @override
  final bool? multiSelect;
  @override
  final String? api;
  @override
  final String? application;
  @override
  final String? keyLabel;
  @override
  final String? keyValue;
  @override
  final bool? multiple;
  final List<Map<String, dynamic>>? _values;
  @override
  List<Map<String, dynamic>>? get values {
    final value = _values;
    if (value == null) return null;
    if (_values is EqualUnmodifiableListView) return _values;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final Map<String, dynamic>? _default_;
  @override
  Map<String, dynamic>? get default_ {
    final value = _default_;
    if (value == null) return null;
    if (_default_ is EqualUnmodifiableMapView) return _default_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? designStyle;
  @override
  final String? dataPath;

  @override
  String toString() {
    return 'GenericFieldConfig(attributLabel: $attributLabel, definition: $definition, hidden: $hidden, required: $required, typeWidget: $typeWidget, typeUtil: $typeUtil, multiSelect: $multiSelect, api: $api, application: $application, keyLabel: $keyLabel, keyValue: $keyValue, multiple: $multiple, values: $values, default_: $default_, designStyle: $designStyle, dataPath: $dataPath)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GenericFieldConfigImpl &&
            (identical(other.attributLabel, attributLabel) ||
                other.attributLabel == attributLabel) &&
            (identical(other.definition, definition) ||
                other.definition == definition) &&
            (identical(other.hidden, hidden) || other.hidden == hidden) &&
            (identical(other.required, required) ||
                other.required == required) &&
            (identical(other.typeWidget, typeWidget) ||
                other.typeWidget == typeWidget) &&
            (identical(other.typeUtil, typeUtil) ||
                other.typeUtil == typeUtil) &&
            (identical(other.multiSelect, multiSelect) ||
                other.multiSelect == multiSelect) &&
            (identical(other.api, api) || other.api == api) &&
            (identical(other.application, application) ||
                other.application == application) &&
            (identical(other.keyLabel, keyLabel) ||
                other.keyLabel == keyLabel) &&
            (identical(other.keyValue, keyValue) ||
                other.keyValue == keyValue) &&
            (identical(other.multiple, multiple) ||
                other.multiple == multiple) &&
            const DeepCollectionEquality().equals(other._values, _values) &&
            const DeepCollectionEquality().equals(other._default_, _default_) &&
            (identical(other.designStyle, designStyle) ||
                other.designStyle == designStyle) &&
            (identical(other.dataPath, dataPath) ||
                other.dataPath == dataPath));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      attributLabel,
      definition,
      hidden,
      required,
      typeWidget,
      typeUtil,
      multiSelect,
      api,
      application,
      keyLabel,
      keyValue,
      multiple,
      const DeepCollectionEquality().hash(_values),
      const DeepCollectionEquality().hash(_default_),
      designStyle,
      dataPath);

  /// Create a copy of GenericFieldConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GenericFieldConfigImplCopyWith<_$GenericFieldConfigImpl> get copyWith =>
      __$$GenericFieldConfigImplCopyWithImpl<_$GenericFieldConfigImpl>(
          this, _$identity);
}

abstract class _GenericFieldConfig implements GenericFieldConfig {
  const factory _GenericFieldConfig(
      {@JsonKey(name: 'attribut_label') final String? attributLabel,
      final String? definition,
      final bool? hidden,
      final bool? required,
      final String? typeWidget,
      final String? typeUtil,
      final bool? multiSelect,
      final String? api,
      final String? application,
      final String? keyLabel,
      final String? keyValue,
      final bool? multiple,
      final List<Map<String, dynamic>>? values,
      final Map<String, dynamic>? default_,
      final String? designStyle,
      final String? dataPath}) = _$GenericFieldConfigImpl;

  @override
  @JsonKey(name: 'attribut_label')
  String? get attributLabel;
  @override
  String? get definition;
  @override
  bool? get hidden;
  @override
  bool? get required;
  @override
  String? get typeWidget;
  @override
  String? get typeUtil;
  @override
  bool? get multiSelect;
  @override
  String? get api;
  @override
  String? get application;
  @override
  String? get keyLabel;
  @override
  String? get keyValue;
  @override
  bool? get multiple;
  @override
  List<Map<String, dynamic>>? get values;
  @override
  Map<String, dynamic>? get default_;
  @override
  String? get designStyle;
  @override
  String? get dataPath;

  /// Create a copy of GenericFieldConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GenericFieldConfigImplCopyWith<_$GenericFieldConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TypeSiteConfig {
  List<dynamic>? get displayProperties => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;

  /// Create a copy of TypeSiteConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TypeSiteConfigCopyWith<TypeSiteConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypeSiteConfigCopyWith<$Res> {
  factory $TypeSiteConfigCopyWith(
          TypeSiteConfig value, $Res Function(TypeSiteConfig) then) =
      _$TypeSiteConfigCopyWithImpl<$Res, TypeSiteConfig>;
  @useResult
  $Res call({List<dynamic>? displayProperties, String? name});
}

/// @nodoc
class _$TypeSiteConfigCopyWithImpl<$Res, $Val extends TypeSiteConfig>
    implements $TypeSiteConfigCopyWith<$Res> {
  _$TypeSiteConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TypeSiteConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? displayProperties = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      displayProperties: freezed == displayProperties
          ? _value.displayProperties
          : displayProperties // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TypeSiteConfigImplCopyWith<$Res>
    implements $TypeSiteConfigCopyWith<$Res> {
  factory _$$TypeSiteConfigImplCopyWith(_$TypeSiteConfigImpl value,
          $Res Function(_$TypeSiteConfigImpl) then) =
      __$$TypeSiteConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<dynamic>? displayProperties, String? name});
}

/// @nodoc
class __$$TypeSiteConfigImplCopyWithImpl<$Res>
    extends _$TypeSiteConfigCopyWithImpl<$Res, _$TypeSiteConfigImpl>
    implements _$$TypeSiteConfigImplCopyWith<$Res> {
  __$$TypeSiteConfigImplCopyWithImpl(
      _$TypeSiteConfigImpl _value, $Res Function(_$TypeSiteConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of TypeSiteConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? displayProperties = freezed,
    Object? name = freezed,
  }) {
    return _then(_$TypeSiteConfigImpl(
      displayProperties: freezed == displayProperties
          ? _value._displayProperties
          : displayProperties // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$TypeSiteConfigImpl implements _TypeSiteConfig {
  const _$TypeSiteConfigImpl(
      {final List<dynamic>? displayProperties, this.name})
      : _displayProperties = displayProperties;

  final List<dynamic>? _displayProperties;
  @override
  List<dynamic>? get displayProperties {
    final value = _displayProperties;
    if (value == null) return null;
    if (_displayProperties is EqualUnmodifiableListView)
      return _displayProperties;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? name;

  @override
  String toString() {
    return 'TypeSiteConfig(displayProperties: $displayProperties, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TypeSiteConfigImpl &&
            const DeepCollectionEquality()
                .equals(other._displayProperties, _displayProperties) &&
            (identical(other.name, name) || other.name == name));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_displayProperties), name);

  /// Create a copy of TypeSiteConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TypeSiteConfigImplCopyWith<_$TypeSiteConfigImpl> get copyWith =>
      __$$TypeSiteConfigImplCopyWithImpl<_$TypeSiteConfigImpl>(
          this, _$identity);
}

abstract class _TypeSiteConfig implements TypeSiteConfig {
  const factory _TypeSiteConfig(
      {final List<dynamic>? displayProperties,
      final String? name}) = _$TypeSiteConfigImpl;

  @override
  List<dynamic>? get displayProperties;
  @override
  String? get name;

  /// Create a copy of TypeSiteConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TypeSiteConfigImplCopyWith<_$TypeSiteConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ObjectConfig {
  bool? get chained => throw _privateConstructorUsedError;
  List<String>? get childrenTypes => throw _privateConstructorUsedError;
  String? get descriptionFieldName => throw _privateConstructorUsedError;
  List<String>? get displayForm => throw _privateConstructorUsedError;
  List<String>? get displayList => throw _privateConstructorUsedError;
  List<String>? get displayProperties => throw _privateConstructorUsedError;
  List<ExportConfig>? get exportPdf => throw _privateConstructorUsedError;
  Map<String, dynamic>? get filters => throw _privateConstructorUsedError;
  Map<String, GenericFieldConfig>? get generic =>
      throw _privateConstructorUsedError;
  String? get genre => throw _privateConstructorUsedError;
  String? get geomFieldName => throw _privateConstructorUsedError;
  String? get geometryType => throw _privateConstructorUsedError;
  String? get idFieldName => throw _privateConstructorUsedError;
  int? get idTableLocation => throw _privateConstructorUsedError;
  String? get label => throw _privateConstructorUsedError;
  String? get labelList => throw _privateConstructorUsedError;
  String? get mapLabelFieldName => throw _privateConstructorUsedError;
  List<String>? get parentTypes => throw _privateConstructorUsedError;
  List<String>? get propertiesKeys => throw _privateConstructorUsedError;
  List<SortConfig>? get sorts => throw _privateConstructorUsedError;
  Map<String, dynamic>? get specific => throw _privateConstructorUsedError;
  Map<String, TypeSiteConfig>? get typesSite =>
      throw _privateConstructorUsedError;
  String? get uuidFieldName => throw _privateConstructorUsedError;

  /// Create a copy of ObjectConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ObjectConfigCopyWith<ObjectConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ObjectConfigCopyWith<$Res> {
  factory $ObjectConfigCopyWith(
          ObjectConfig value, $Res Function(ObjectConfig) then) =
      _$ObjectConfigCopyWithImpl<$Res, ObjectConfig>;
  @useResult
  $Res call(
      {bool? chained,
      List<String>? childrenTypes,
      String? descriptionFieldName,
      List<String>? displayForm,
      List<String>? displayList,
      List<String>? displayProperties,
      List<ExportConfig>? exportPdf,
      Map<String, dynamic>? filters,
      Map<String, GenericFieldConfig>? generic,
      String? genre,
      String? geomFieldName,
      String? geometryType,
      String? idFieldName,
      int? idTableLocation,
      String? label,
      String? labelList,
      String? mapLabelFieldName,
      List<String>? parentTypes,
      List<String>? propertiesKeys,
      List<SortConfig>? sorts,
      Map<String, dynamic>? specific,
      Map<String, TypeSiteConfig>? typesSite,
      String? uuidFieldName});
}

/// @nodoc
class _$ObjectConfigCopyWithImpl<$Res, $Val extends ObjectConfig>
    implements $ObjectConfigCopyWith<$Res> {
  _$ObjectConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ObjectConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chained = freezed,
    Object? childrenTypes = freezed,
    Object? descriptionFieldName = freezed,
    Object? displayForm = freezed,
    Object? displayList = freezed,
    Object? displayProperties = freezed,
    Object? exportPdf = freezed,
    Object? filters = freezed,
    Object? generic = freezed,
    Object? genre = freezed,
    Object? geomFieldName = freezed,
    Object? geometryType = freezed,
    Object? idFieldName = freezed,
    Object? idTableLocation = freezed,
    Object? label = freezed,
    Object? labelList = freezed,
    Object? mapLabelFieldName = freezed,
    Object? parentTypes = freezed,
    Object? propertiesKeys = freezed,
    Object? sorts = freezed,
    Object? specific = freezed,
    Object? typesSite = freezed,
    Object? uuidFieldName = freezed,
  }) {
    return _then(_value.copyWith(
      chained: freezed == chained
          ? _value.chained
          : chained // ignore: cast_nullable_to_non_nullable
              as bool?,
      childrenTypes: freezed == childrenTypes
          ? _value.childrenTypes
          : childrenTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      descriptionFieldName: freezed == descriptionFieldName
          ? _value.descriptionFieldName
          : descriptionFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      displayForm: freezed == displayForm
          ? _value.displayForm
          : displayForm // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      displayList: freezed == displayList
          ? _value.displayList
          : displayList // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      displayProperties: freezed == displayProperties
          ? _value.displayProperties
          : displayProperties // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      exportPdf: freezed == exportPdf
          ? _value.exportPdf
          : exportPdf // ignore: cast_nullable_to_non_nullable
              as List<ExportConfig>?,
      filters: freezed == filters
          ? _value.filters
          : filters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      generic: freezed == generic
          ? _value.generic
          : generic // ignore: cast_nullable_to_non_nullable
              as Map<String, GenericFieldConfig>?,
      genre: freezed == genre
          ? _value.genre
          : genre // ignore: cast_nullable_to_non_nullable
              as String?,
      geomFieldName: freezed == geomFieldName
          ? _value.geomFieldName
          : geomFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      geometryType: freezed == geometryType
          ? _value.geometryType
          : geometryType // ignore: cast_nullable_to_non_nullable
              as String?,
      idFieldName: freezed == idFieldName
          ? _value.idFieldName
          : idFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      idTableLocation: freezed == idTableLocation
          ? _value.idTableLocation
          : idTableLocation // ignore: cast_nullable_to_non_nullable
              as int?,
      label: freezed == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String?,
      labelList: freezed == labelList
          ? _value.labelList
          : labelList // ignore: cast_nullable_to_non_nullable
              as String?,
      mapLabelFieldName: freezed == mapLabelFieldName
          ? _value.mapLabelFieldName
          : mapLabelFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      parentTypes: freezed == parentTypes
          ? _value.parentTypes
          : parentTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      propertiesKeys: freezed == propertiesKeys
          ? _value.propertiesKeys
          : propertiesKeys // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      sorts: freezed == sorts
          ? _value.sorts
          : sorts // ignore: cast_nullable_to_non_nullable
              as List<SortConfig>?,
      specific: freezed == specific
          ? _value.specific
          : specific // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      typesSite: freezed == typesSite
          ? _value.typesSite
          : typesSite // ignore: cast_nullable_to_non_nullable
              as Map<String, TypeSiteConfig>?,
      uuidFieldName: freezed == uuidFieldName
          ? _value.uuidFieldName
          : uuidFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ObjectConfigImplCopyWith<$Res>
    implements $ObjectConfigCopyWith<$Res> {
  factory _$$ObjectConfigImplCopyWith(
          _$ObjectConfigImpl value, $Res Function(_$ObjectConfigImpl) then) =
      __$$ObjectConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool? chained,
      List<String>? childrenTypes,
      String? descriptionFieldName,
      List<String>? displayForm,
      List<String>? displayList,
      List<String>? displayProperties,
      List<ExportConfig>? exportPdf,
      Map<String, dynamic>? filters,
      Map<String, GenericFieldConfig>? generic,
      String? genre,
      String? geomFieldName,
      String? geometryType,
      String? idFieldName,
      int? idTableLocation,
      String? label,
      String? labelList,
      String? mapLabelFieldName,
      List<String>? parentTypes,
      List<String>? propertiesKeys,
      List<SortConfig>? sorts,
      Map<String, dynamic>? specific,
      Map<String, TypeSiteConfig>? typesSite,
      String? uuidFieldName});
}

/// @nodoc
class __$$ObjectConfigImplCopyWithImpl<$Res>
    extends _$ObjectConfigCopyWithImpl<$Res, _$ObjectConfigImpl>
    implements _$$ObjectConfigImplCopyWith<$Res> {
  __$$ObjectConfigImplCopyWithImpl(
      _$ObjectConfigImpl _value, $Res Function(_$ObjectConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of ObjectConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chained = freezed,
    Object? childrenTypes = freezed,
    Object? descriptionFieldName = freezed,
    Object? displayForm = freezed,
    Object? displayList = freezed,
    Object? displayProperties = freezed,
    Object? exportPdf = freezed,
    Object? filters = freezed,
    Object? generic = freezed,
    Object? genre = freezed,
    Object? geomFieldName = freezed,
    Object? geometryType = freezed,
    Object? idFieldName = freezed,
    Object? idTableLocation = freezed,
    Object? label = freezed,
    Object? labelList = freezed,
    Object? mapLabelFieldName = freezed,
    Object? parentTypes = freezed,
    Object? propertiesKeys = freezed,
    Object? sorts = freezed,
    Object? specific = freezed,
    Object? typesSite = freezed,
    Object? uuidFieldName = freezed,
  }) {
    return _then(_$ObjectConfigImpl(
      chained: freezed == chained
          ? _value.chained
          : chained // ignore: cast_nullable_to_non_nullable
              as bool?,
      childrenTypes: freezed == childrenTypes
          ? _value._childrenTypes
          : childrenTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      descriptionFieldName: freezed == descriptionFieldName
          ? _value.descriptionFieldName
          : descriptionFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      displayForm: freezed == displayForm
          ? _value._displayForm
          : displayForm // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      displayList: freezed == displayList
          ? _value._displayList
          : displayList // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      displayProperties: freezed == displayProperties
          ? _value._displayProperties
          : displayProperties // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      exportPdf: freezed == exportPdf
          ? _value._exportPdf
          : exportPdf // ignore: cast_nullable_to_non_nullable
              as List<ExportConfig>?,
      filters: freezed == filters
          ? _value._filters
          : filters // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      generic: freezed == generic
          ? _value._generic
          : generic // ignore: cast_nullable_to_non_nullable
              as Map<String, GenericFieldConfig>?,
      genre: freezed == genre
          ? _value.genre
          : genre // ignore: cast_nullable_to_non_nullable
              as String?,
      geomFieldName: freezed == geomFieldName
          ? _value.geomFieldName
          : geomFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      geometryType: freezed == geometryType
          ? _value.geometryType
          : geometryType // ignore: cast_nullable_to_non_nullable
              as String?,
      idFieldName: freezed == idFieldName
          ? _value.idFieldName
          : idFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      idTableLocation: freezed == idTableLocation
          ? _value.idTableLocation
          : idTableLocation // ignore: cast_nullable_to_non_nullable
              as int?,
      label: freezed == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String?,
      labelList: freezed == labelList
          ? _value.labelList
          : labelList // ignore: cast_nullable_to_non_nullable
              as String?,
      mapLabelFieldName: freezed == mapLabelFieldName
          ? _value.mapLabelFieldName
          : mapLabelFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
      parentTypes: freezed == parentTypes
          ? _value._parentTypes
          : parentTypes // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      propertiesKeys: freezed == propertiesKeys
          ? _value._propertiesKeys
          : propertiesKeys // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      sorts: freezed == sorts
          ? _value._sorts
          : sorts // ignore: cast_nullable_to_non_nullable
              as List<SortConfig>?,
      specific: freezed == specific
          ? _value._specific
          : specific // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      typesSite: freezed == typesSite
          ? _value._typesSite
          : typesSite // ignore: cast_nullable_to_non_nullable
              as Map<String, TypeSiteConfig>?,
      uuidFieldName: freezed == uuidFieldName
          ? _value.uuidFieldName
          : uuidFieldName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ObjectConfigImpl implements _ObjectConfig {
  const _$ObjectConfigImpl(
      {this.chained,
      final List<String>? childrenTypes,
      this.descriptionFieldName,
      final List<String>? displayForm,
      final List<String>? displayList,
      final List<String>? displayProperties,
      final List<ExportConfig>? exportPdf,
      final Map<String, dynamic>? filters,
      final Map<String, GenericFieldConfig>? generic,
      this.genre,
      this.geomFieldName,
      this.geometryType,
      this.idFieldName,
      this.idTableLocation,
      this.label,
      this.labelList,
      this.mapLabelFieldName,
      final List<String>? parentTypes,
      final List<String>? propertiesKeys,
      final List<SortConfig>? sorts,
      final Map<String, dynamic>? specific,
      final Map<String, TypeSiteConfig>? typesSite,
      this.uuidFieldName})
      : _childrenTypes = childrenTypes,
        _displayForm = displayForm,
        _displayList = displayList,
        _displayProperties = displayProperties,
        _exportPdf = exportPdf,
        _filters = filters,
        _generic = generic,
        _parentTypes = parentTypes,
        _propertiesKeys = propertiesKeys,
        _sorts = sorts,
        _specific = specific,
        _typesSite = typesSite;

  @override
  final bool? chained;
  final List<String>? _childrenTypes;
  @override
  List<String>? get childrenTypes {
    final value = _childrenTypes;
    if (value == null) return null;
    if (_childrenTypes is EqualUnmodifiableListView) return _childrenTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? descriptionFieldName;
  final List<String>? _displayForm;
  @override
  List<String>? get displayForm {
    final value = _displayForm;
    if (value == null) return null;
    if (_displayForm is EqualUnmodifiableListView) return _displayForm;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _displayList;
  @override
  List<String>? get displayList {
    final value = _displayList;
    if (value == null) return null;
    if (_displayList is EqualUnmodifiableListView) return _displayList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _displayProperties;
  @override
  List<String>? get displayProperties {
    final value = _displayProperties;
    if (value == null) return null;
    if (_displayProperties is EqualUnmodifiableListView)
      return _displayProperties;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<ExportConfig>? _exportPdf;
  @override
  List<ExportConfig>? get exportPdf {
    final value = _exportPdf;
    if (value == null) return null;
    if (_exportPdf is EqualUnmodifiableListView) return _exportPdf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final Map<String, dynamic>? _filters;
  @override
  Map<String, dynamic>? get filters {
    final value = _filters;
    if (value == null) return null;
    if (_filters is EqualUnmodifiableMapView) return _filters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, GenericFieldConfig>? _generic;
  @override
  Map<String, GenericFieldConfig>? get generic {
    final value = _generic;
    if (value == null) return null;
    if (_generic is EqualUnmodifiableMapView) return _generic;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? genre;
  @override
  final String? geomFieldName;
  @override
  final String? geometryType;
  @override
  final String? idFieldName;
  @override
  final int? idTableLocation;
  @override
  final String? label;
  @override
  final String? labelList;
  @override
  final String? mapLabelFieldName;
  final List<String>? _parentTypes;
  @override
  List<String>? get parentTypes {
    final value = _parentTypes;
    if (value == null) return null;
    if (_parentTypes is EqualUnmodifiableListView) return _parentTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _propertiesKeys;
  @override
  List<String>? get propertiesKeys {
    final value = _propertiesKeys;
    if (value == null) return null;
    if (_propertiesKeys is EqualUnmodifiableListView) return _propertiesKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<SortConfig>? _sorts;
  @override
  List<SortConfig>? get sorts {
    final value = _sorts;
    if (value == null) return null;
    if (_sorts is EqualUnmodifiableListView) return _sorts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final Map<String, dynamic>? _specific;
  @override
  Map<String, dynamic>? get specific {
    final value = _specific;
    if (value == null) return null;
    if (_specific is EqualUnmodifiableMapView) return _specific;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, TypeSiteConfig>? _typesSite;
  @override
  Map<String, TypeSiteConfig>? get typesSite {
    final value = _typesSite;
    if (value == null) return null;
    if (_typesSite is EqualUnmodifiableMapView) return _typesSite;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? uuidFieldName;

  @override
  String toString() {
    return 'ObjectConfig(chained: $chained, childrenTypes: $childrenTypes, descriptionFieldName: $descriptionFieldName, displayForm: $displayForm, displayList: $displayList, displayProperties: $displayProperties, exportPdf: $exportPdf, filters: $filters, generic: $generic, genre: $genre, geomFieldName: $geomFieldName, geometryType: $geometryType, idFieldName: $idFieldName, idTableLocation: $idTableLocation, label: $label, labelList: $labelList, mapLabelFieldName: $mapLabelFieldName, parentTypes: $parentTypes, propertiesKeys: $propertiesKeys, sorts: $sorts, specific: $specific, typesSite: $typesSite, uuidFieldName: $uuidFieldName)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ObjectConfigImpl &&
            (identical(other.chained, chained) || other.chained == chained) &&
            const DeepCollectionEquality()
                .equals(other._childrenTypes, _childrenTypes) &&
            (identical(other.descriptionFieldName, descriptionFieldName) ||
                other.descriptionFieldName == descriptionFieldName) &&
            const DeepCollectionEquality()
                .equals(other._displayForm, _displayForm) &&
            const DeepCollectionEquality()
                .equals(other._displayList, _displayList) &&
            const DeepCollectionEquality()
                .equals(other._displayProperties, _displayProperties) &&
            const DeepCollectionEquality()
                .equals(other._exportPdf, _exportPdf) &&
            const DeepCollectionEquality().equals(other._filters, _filters) &&
            const DeepCollectionEquality().equals(other._generic, _generic) &&
            (identical(other.genre, genre) || other.genre == genre) &&
            (identical(other.geomFieldName, geomFieldName) ||
                other.geomFieldName == geomFieldName) &&
            (identical(other.geometryType, geometryType) ||
                other.geometryType == geometryType) &&
            (identical(other.idFieldName, idFieldName) ||
                other.idFieldName == idFieldName) &&
            (identical(other.idTableLocation, idTableLocation) ||
                other.idTableLocation == idTableLocation) &&
            (identical(other.label, label) || other.label == label) &&
            (identical(other.labelList, labelList) ||
                other.labelList == labelList) &&
            (identical(other.mapLabelFieldName, mapLabelFieldName) ||
                other.mapLabelFieldName == mapLabelFieldName) &&
            const DeepCollectionEquality()
                .equals(other._parentTypes, _parentTypes) &&
            const DeepCollectionEquality()
                .equals(other._propertiesKeys, _propertiesKeys) &&
            const DeepCollectionEquality().equals(other._sorts, _sorts) &&
            const DeepCollectionEquality().equals(other._specific, _specific) &&
            const DeepCollectionEquality()
                .equals(other._typesSite, _typesSite) &&
            (identical(other.uuidFieldName, uuidFieldName) ||
                other.uuidFieldName == uuidFieldName));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        chained,
        const DeepCollectionEquality().hash(_childrenTypes),
        descriptionFieldName,
        const DeepCollectionEquality().hash(_displayForm),
        const DeepCollectionEquality().hash(_displayList),
        const DeepCollectionEquality().hash(_displayProperties),
        const DeepCollectionEquality().hash(_exportPdf),
        const DeepCollectionEquality().hash(_filters),
        const DeepCollectionEquality().hash(_generic),
        genre,
        geomFieldName,
        geometryType,
        idFieldName,
        idTableLocation,
        label,
        labelList,
        mapLabelFieldName,
        const DeepCollectionEquality().hash(_parentTypes),
        const DeepCollectionEquality().hash(_propertiesKeys),
        const DeepCollectionEquality().hash(_sorts),
        const DeepCollectionEquality().hash(_specific),
        const DeepCollectionEquality().hash(_typesSite),
        uuidFieldName
      ]);

  /// Create a copy of ObjectConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ObjectConfigImplCopyWith<_$ObjectConfigImpl> get copyWith =>
      __$$ObjectConfigImplCopyWithImpl<_$ObjectConfigImpl>(this, _$identity);
}

abstract class _ObjectConfig implements ObjectConfig {
  const factory _ObjectConfig(
      {final bool? chained,
      final List<String>? childrenTypes,
      final String? descriptionFieldName,
      final List<String>? displayForm,
      final List<String>? displayList,
      final List<String>? displayProperties,
      final List<ExportConfig>? exportPdf,
      final Map<String, dynamic>? filters,
      final Map<String, GenericFieldConfig>? generic,
      final String? genre,
      final String? geomFieldName,
      final String? geometryType,
      final String? idFieldName,
      final int? idTableLocation,
      final String? label,
      final String? labelList,
      final String? mapLabelFieldName,
      final List<String>? parentTypes,
      final List<String>? propertiesKeys,
      final List<SortConfig>? sorts,
      final Map<String, dynamic>? specific,
      final Map<String, TypeSiteConfig>? typesSite,
      final String? uuidFieldName}) = _$ObjectConfigImpl;

  @override
  bool? get chained;
  @override
  List<String>? get childrenTypes;
  @override
  String? get descriptionFieldName;
  @override
  List<String>? get displayForm;
  @override
  List<String>? get displayList;
  @override
  List<String>? get displayProperties;
  @override
  List<ExportConfig>? get exportPdf;
  @override
  Map<String, dynamic>? get filters;
  @override
  Map<String, GenericFieldConfig>? get generic;
  @override
  String? get genre;
  @override
  String? get geomFieldName;
  @override
  String? get geometryType;
  @override
  String? get idFieldName;
  @override
  int? get idTableLocation;
  @override
  String? get label;
  @override
  String? get labelList;
  @override
  String? get mapLabelFieldName;
  @override
  List<String>? get parentTypes;
  @override
  List<String>? get propertiesKeys;
  @override
  List<SortConfig>? get sorts;
  @override
  Map<String, dynamic>? get specific;
  @override
  Map<String, TypeSiteConfig>? get typesSite;
  @override
  String? get uuidFieldName;

  /// Create a copy of ObjectConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ObjectConfigImplCopyWith<_$ObjectConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SortConfig {
  String? get dir => throw _privateConstructorUsedError;
  String? get prop => throw _privateConstructorUsedError;

  /// Create a copy of SortConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SortConfigCopyWith<SortConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SortConfigCopyWith<$Res> {
  factory $SortConfigCopyWith(
          SortConfig value, $Res Function(SortConfig) then) =
      _$SortConfigCopyWithImpl<$Res, SortConfig>;
  @useResult
  $Res call({String? dir, String? prop});
}

/// @nodoc
class _$SortConfigCopyWithImpl<$Res, $Val extends SortConfig>
    implements $SortConfigCopyWith<$Res> {
  _$SortConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SortConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dir = freezed,
    Object? prop = freezed,
  }) {
    return _then(_value.copyWith(
      dir: freezed == dir
          ? _value.dir
          : dir // ignore: cast_nullable_to_non_nullable
              as String?,
      prop: freezed == prop
          ? _value.prop
          : prop // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SortConfigImplCopyWith<$Res>
    implements $SortConfigCopyWith<$Res> {
  factory _$$SortConfigImplCopyWith(
          _$SortConfigImpl value, $Res Function(_$SortConfigImpl) then) =
      __$$SortConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? dir, String? prop});
}

/// @nodoc
class __$$SortConfigImplCopyWithImpl<$Res>
    extends _$SortConfigCopyWithImpl<$Res, _$SortConfigImpl>
    implements _$$SortConfigImplCopyWith<$Res> {
  __$$SortConfigImplCopyWithImpl(
      _$SortConfigImpl _value, $Res Function(_$SortConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of SortConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dir = freezed,
    Object? prop = freezed,
  }) {
    return _then(_$SortConfigImpl(
      dir: freezed == dir
          ? _value.dir
          : dir // ignore: cast_nullable_to_non_nullable
              as String?,
      prop: freezed == prop
          ? _value.prop
          : prop // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$SortConfigImpl implements _SortConfig {
  const _$SortConfigImpl({this.dir, this.prop});

  @override
  final String? dir;
  @override
  final String? prop;

  @override
  String toString() {
    return 'SortConfig(dir: $dir, prop: $prop)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SortConfigImpl &&
            (identical(other.dir, dir) || other.dir == dir) &&
            (identical(other.prop, prop) || other.prop == prop));
  }

  @override
  int get hashCode => Object.hash(runtimeType, dir, prop);

  /// Create a copy of SortConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SortConfigImplCopyWith<_$SortConfigImpl> get copyWith =>
      __$$SortConfigImplCopyWithImpl<_$SortConfigImpl>(this, _$identity);
}

abstract class _SortConfig implements SortConfig {
  const factory _SortConfig({final String? dir, final String? prop}) =
      _$SortConfigImpl;

  @override
  String? get dir;
  @override
  String? get prop;

  /// Create a copy of SortConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SortConfigImplCopyWith<_$SortConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TreeConfig {
  Map<String, dynamic>? get module => throw _privateConstructorUsedError;

  /// Create a copy of TreeConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TreeConfigCopyWith<TreeConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TreeConfigCopyWith<$Res> {
  factory $TreeConfigCopyWith(
          TreeConfig value, $Res Function(TreeConfig) then) =
      _$TreeConfigCopyWithImpl<$Res, TreeConfig>;
  @useResult
  $Res call({Map<String, dynamic>? module});
}

/// @nodoc
class _$TreeConfigCopyWithImpl<$Res, $Val extends TreeConfig>
    implements $TreeConfigCopyWith<$Res> {
  _$TreeConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TreeConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? module = freezed,
  }) {
    return _then(_value.copyWith(
      module: freezed == module
          ? _value.module
          : module // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TreeConfigImplCopyWith<$Res>
    implements $TreeConfigCopyWith<$Res> {
  factory _$$TreeConfigImplCopyWith(
          _$TreeConfigImpl value, $Res Function(_$TreeConfigImpl) then) =
      __$$TreeConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Map<String, dynamic>? module});
}

/// @nodoc
class __$$TreeConfigImplCopyWithImpl<$Res>
    extends _$TreeConfigCopyWithImpl<$Res, _$TreeConfigImpl>
    implements _$$TreeConfigImplCopyWith<$Res> {
  __$$TreeConfigImplCopyWithImpl(
      _$TreeConfigImpl _value, $Res Function(_$TreeConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of TreeConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? module = freezed,
  }) {
    return _then(_$TreeConfigImpl(
      module: freezed == module
          ? _value._module
          : module // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc

class _$TreeConfigImpl implements _TreeConfig {
  const _$TreeConfigImpl({final Map<String, dynamic>? module})
      : _module = module;

  final Map<String, dynamic>? _module;
  @override
  Map<String, dynamic>? get module {
    final value = _module;
    if (value == null) return null;
    if (_module is EqualUnmodifiableMapView) return _module;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'TreeConfig(module: $module)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TreeConfigImpl &&
            const DeepCollectionEquality().equals(other._module, _module));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_module));

  /// Create a copy of TreeConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TreeConfigImplCopyWith<_$TreeConfigImpl> get copyWith =>
      __$$TreeConfigImplCopyWithImpl<_$TreeConfigImpl>(this, _$identity);
}

abstract class _TreeConfig implements TreeConfig {
  const factory _TreeConfig({final Map<String, dynamic>? module}) =
      _$TreeConfigImpl;

  @override
  Map<String, dynamic>? get module;

  /// Create a copy of TreeConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TreeConfigImplCopyWith<_$TreeConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
